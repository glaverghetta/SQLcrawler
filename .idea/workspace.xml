<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="1b563e04-2a7e-411d-bd18-6a7ab852e566" name="Default" comment="">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeAnalyzer.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeAnalyzer.java" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeStatistics.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeStatistics.java" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/RegexConstants.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/RegexConstants.java" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/UrlConstants.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/UrlConstants.java" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SQLTypeDTO.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SQLTypeDTO.java" afterDir="false" />
    </list>
    <ignored path="$PROJECT_DIR$/out/" />
    <ignored path="$PROJECT_DIR$/target/" />
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="CrawlerMain.java" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="248">
              <caret line="24" selection-start-line="24" selection-end-line="24" />
              <folding>
                <element signature="imports" expanded="true" />
              </folding>
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="SearchData.java" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SearchData.java">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="309">
              <caret line="36" selection-start-line="36" selection-end-line="36" />
              <folding>
                <element signature="e#733#734#0" expanded="true" />
              </folding>
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="UrlConstants.java" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/UrlConstants.java">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="90">
              <caret line="6" column="52" selection-start-line="6" selection-start-column="52" selection-end-line="6" selection-end-column="52" />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="CodeAnalyzer.java" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeAnalyzer.java">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="151">
              <caret line="63" column="57" selection-start-line="63" selection-start-column="53" selection-end-line="63" selection-end-column="57" />
              <folding>
                <element signature="imports" expanded="true" />
              </folding>
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="SQLTypeDTO.java" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SQLTypeDTO.java">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="300">
              <caret line="20" column="34" selection-start-line="20" selection-start-column="19" selection-end-line="20" selection-end-column="34" />
              <folding>
                <element signature="e#316#317#0" expanded="true" />
                <element signature="e#347#348#0" expanded="true" />
                <element signature="e#553#554#0" expanded="true" />
                <element signature="e#587#588#0" expanded="true" />
              </folding>
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="CodeStatistics.java" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeStatistics.java">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="1530">
              <caret line="102" column="54" selection-start-line="102" selection-start-column="54" selection-end-line="102" selection-end-column="54" />
              <folding>
                <element signature="imports" expanded="true" />
              </folding>
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="RegexConstants.java" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/RegexConstants.java">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="60">
              <caret line="4" column="112" selection-start-line="4" selection-start-column="67" selection-end-line="4" selection-end-column="112" />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Enum" />
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>|</find>
      <find>mStringLitWithLikePattern</find>
    </findStrings>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
    <option name="RECENT_BRANCH_BY_REPOSITORY">
      <map>
        <entry key="$PROJECT_DIR$" value="orderby" />
      </map>
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/parser/JavaCodeParser.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/parser/constants/CredentialConstants.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/CredentialConstants.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/io/HttpConnection.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SearchCodeResult.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/Results.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/utils/UrlUtils.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analizer/CodeStatistics.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analizer/CodeAnalizer.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analizer/CodeAnalyzer.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SQLType.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/provider/SourceCodeProvider.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SearchData.java" />
        <option value="$PROJECT_DIR$/pom.xml" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/provider/SearchCodeProvider.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/CodeStatData.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SQLTypeDTO.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeAnalyzer.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeStatistics.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/RegexConstants.java" />
        <option value="$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/UrlConstants.java" />
      </list>
    </option>
  </component>
  <component name="JsBuildToolGruntFileManager" detection-done="true" sorting="DEFINITION_ORDER" />
  <component name="JsBuildToolPackageJson" detection-done="true" sorting="DEFINITION_ORDER" />
  <component name="JsGulpfileManager">
    <detection-done>true</detection-done>
    <sorting>DEFINITION_ORDER</sorting>
  </component>
  <component name="MavenImportPreferences">
    <option name="importingSettings">
      <MavenImportingSettings>
        <option name="importAutomatically" value="true" />
      </MavenImportingSettings>
    </option>
  </component>
  <component name="NodePackageJsonFileManager">
    <packageJsonPaths />
  </component>
  <component name="ProjectFrameBounds" extendedState="6">
    <option name="y" value="22" />
    <option name="width" value="1440" />
    <option name="height" value="878" />
  </component>
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectView">
    <navigator proportions="" version="1">
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="Sqlcrawler" type="b2602c69:ProjectViewProjectNode" />
              <item name="Sqlcrawler" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="Sqlcrawler" type="b2602c69:ProjectViewProjectNode" />
              <item name="Sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="Sqlcrawler" type="b2602c69:ProjectViewProjectNode" />
              <item name="Sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="main" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="Sqlcrawler" type="b2602c69:ProjectViewProjectNode" />
              <item name="Sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="main" type="462c0819:PsiDirectoryNode" />
              <item name="java" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="Sqlcrawler" type="b2602c69:ProjectViewProjectNode" />
              <item name="Sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="main" type="462c0819:PsiDirectoryNode" />
              <item name="java" type="462c0819:PsiDirectoryNode" />
              <item name="sqlcrawler" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="Sqlcrawler" type="b2602c69:ProjectViewProjectNode" />
              <item name="Sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="main" type="462c0819:PsiDirectoryNode" />
              <item name="java" type="462c0819:PsiDirectoryNode" />
              <item name="sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="analyze" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="Sqlcrawler" type="b2602c69:ProjectViewProjectNode" />
              <item name="Sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="main" type="462c0819:PsiDirectoryNode" />
              <item name="java" type="462c0819:PsiDirectoryNode" />
              <item name="sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="constants" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="Sqlcrawler" type="b2602c69:ProjectViewProjectNode" />
              <item name="Sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="main" type="462c0819:PsiDirectoryNode" />
              <item name="java" type="462c0819:PsiDirectoryNode" />
              <item name="sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="io" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="Sqlcrawler" type="b2602c69:ProjectViewProjectNode" />
              <item name="Sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="main" type="462c0819:PsiDirectoryNode" />
              <item name="java" type="462c0819:PsiDirectoryNode" />
              <item name="sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="model" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="Sqlcrawler" type="b2602c69:ProjectViewProjectNode" />
              <item name="Sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="main" type="462c0819:PsiDirectoryNode" />
              <item name="java" type="462c0819:PsiDirectoryNode" />
              <item name="sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="provider" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="Sqlcrawler" type="b2602c69:ProjectViewProjectNode" />
              <item name="Sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="main" type="462c0819:PsiDirectoryNode" />
              <item name="java" type="462c0819:PsiDirectoryNode" />
              <item name="sqlcrawler" type="462c0819:PsiDirectoryNode" />
              <item name="utils" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="PackagesPane" />
      <pane id="Scope" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="aspect.path.notification.shown" value="true" />
    <property name="extract.method.default.visibility" value="private" />
    <property name="ignore_missing_gitignore" value="true" />
    <property name="nodejs_interpreter_path.stuck_in_default_project" value="/usr/local/bin/node" />
    <property name="nodejs_npm_path_reset_for_default_project" value="true" />
    <property name="project.structure.last.edited" value="SDKs" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.2" />
  </component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Application.java run">
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
    </configuration>
    <configuration name="java run" type="Application" factoryName="Application">
      <option name="MAIN_CLASS_NAME" value="usf.edu.bronie.sqlcrawler.CrawlerMain" />
      <module name="Sqlcrawler" />
      <option name="WORKING_DIRECTORY" value="file://$PROJECT_DIR$" />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <patterns />
    </configuration>
    <configuration name="mvn run" type="MavenRunConfiguration" factoryName="Maven">
      <MavenSettings>
        <option name="myGeneralSettings" />
        <option name="myRunnerSettings" />
        <option name="myRunnerParameters">
          <MavenRunnerParameters>
            <option name="profiles">
              <set />
            </option>
            <option name="goals">
              <list>
                <option value="clean" />
                <option value="install" />
                <option value="exec:java" />
              </list>
            </option>
            <option name="pomFileName" />
            <option name="profilesMap">
              <map />
            </option>
            <option name="resolveToWorkspace" value="false" />
            <option name="workingDirPath" value="$PROJECT_DIR$" />
          </MavenRunnerParameters>
        </option>
      </MavenSettings>
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <properties />
      <listeners />
    </configuration>
    <list>
      <item itemvalue="Application.java run" />
      <item itemvalue="Maven.mvn run" />
    </list>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="1b563e04-2a7e-411d-bd18-6a7ab852e566" name="Default" comment="" />
      <created>1529432029506</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1529432029506</updated>
      <workItem from="1529432031295" duration="2964000" />
      <workItem from="1529502515032" duration="7023000" />
      <workItem from="1529589693373" duration="3260000" />
      <workItem from="1529934503896" duration="9107000" />
      <workItem from="1530022484299" duration="9336000" />
      <workItem from="1530212264166" duration="3223000" />
      <workItem from="1530295710479" duration="5746000" />
      <workItem from="1530543899169" duration="8720000" />
    </task>
    <servers />
  </component>
  <component name="TimeTrackingManager">
    <option name="totallyTimeSpent" value="50439000" />
  </component>
  <component name="TodoView">
    <todo-panel id="selected-file">
      <is-autoscroll-to-source value="true" />
    </todo-panel>
    <todo-panel id="all">
      <are-packages-shown value="true" />
      <is-autoscroll-to-source value="true" />
    </todo-panel>
  </component>
  <component name="ToolWindowManager">
    <frame x="0" y="22" width="1440" height="878" extended-state="6" />
    <layout>
      <window_info anchor="right" id="Palette" order="3" />
      <window_info anchor="bottom" id="TODO" order="6" weight="0.3290653" />
      <window_info id="DB Browser" order="2" />
      <window_info anchor="bottom" id="Messages" order="7" weight="0.3290653" />
      <window_info anchor="right" id="Palette&#9;" order="3" />
      <window_info anchor="bottom" id="DB Execution Console" order="7" />
      <window_info anchor="bottom" id="Event Log" order="7" side_tool="true" />
      <window_info anchor="right" id="Maven Projects" order="3" />
      <window_info anchor="bottom" id="Database Changes" order="7" show_stripe_button="false" />
      <window_info anchor="bottom" id="Version Control" order="7" />
      <window_info anchor="bottom" id="Run" order="2" weight="0.43661973" />
      <window_info anchor="bottom" id="Terminal" order="7" weight="0.3290653" />
      <window_info id="Designer" order="2" />
      <window_info content_ui="combo" id="Project" order="0" visible="true" weight="0.26752505" />
      <window_info anchor="right" id="Database" order="3" />
      <window_info anchor="bottom" id="Find" order="1" weight="0.3290653" />
      <window_info id="Structure" order="1" side_tool="true" weight="0.25" />
      <window_info anchor="right" id="Ant Build" order="1" weight="0.25" />
      <window_info id="UI Designer" order="2" />
      <window_info id="Favorites" order="2" side_tool="true" />
      <window_info anchor="bottom" id="Debug" order="3" weight="0.39948782" />
      <window_info anchor="right" content_ui="combo" id="Hierarchy" order="2" weight="0.25" />
      <window_info anchor="bottom" id="Inspection" order="5" weight="0.4" />
      <window_info anchor="right" id="Commander" order="0" weight="0.4" />
      <window_info anchor="bottom" id="Message" order="0" />
      <window_info anchor="bottom" id="Cvs" order="4" weight="0.25" />
    </layout>
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="VcsManagerConfiguration">
    <MESSAGE value="add group by search" />
    <option name="LAST_COMMIT_MESSAGE" value="add group by search" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/JavaCodeParser.java</url>
          <line>8</line>
          <properties />
          <option name="timeStamp" value="2" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <condition expression="i==15" language="JAVA" />
          <url>file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java</url>
          <line>23</line>
          <properties />
          <option name="timeStamp" value="35" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeAnalyzer.java</url>
          <line>66</line>
          <properties />
          <option name="timeStamp" value="36" />
        </line-breakpoint>
      </breakpoints>
      <option name="time" value="37" />
    </breakpoint-manager>
  </component>
  <component name="debuggerHistoryManager">
    <expressions id="breakpointCondition">
      <expression>
        <expression-string>i==15</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>i==12</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
    </expressions>
    <expressions id="setValue">
      <expression>
        <expression-string>&quot;/*  * Copyright 2011 Tyler Blair. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *    1. Redistributions of source code must retain the above copyright notice, this list of  *       conditions and the following disclaimer.  *  *    2. Redistributions in binary form must reproduce the above copyright notice, this list  *       of conditions and the following disclaimer in the documentation and/or other materials  *       provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are those of the  * authors and contributors and should not be interpreted as representing official policies,  * either expressed or implied, of anybody else.  */  package com.griefcraft.sql;  import com.griefcraft.cache.ProtectionCache; import com.griefcraft.lwc.LWC; import com.griefcraft.model.Flag; import com.griefcraft.model.History; import com.griefcraft.model.Permission; import com.griefcraft.model.Protection; import org.bukkit.entity.Player; import org.json.simple.JSONArray; import org.json.simple.JSONObject; import org.json.simple.parser.JSONParser;  import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.sql.Timestamp; import java.util.ArrayList; import java.util.Date; import java.util.List;  public class PhysDB extends Database {      /**      * The JSON Parser object      */     private final JSONParser jsonParser = new JSONParser();      /**      * The database version      */     private int databaseVersion = 0;      /**      * The number of protections that should exist      */     private int protectionCount = 0;      public PhysDB() {         super();     }      public PhysDB(Type currentType) {         super(currentType);     }      /**      * Decrement the known protection counter      */     public void decrementProtectionCount() {         protectionCount --;     }      /**      * Check if the protection cache has all of the known protections cached      *      * @return      */     public boolean hasAllProtectionsCached() {         ProtectionCache cache = LWC.getInstance().getProtectionCache();          return cache.size() &gt;= protectionCount;     }      /**      * Fetch an object from the sql database      *      * @param sql      * @param column      * @return      */     private Object fetch(String sql, String column, Object... toBind) {         PreparedStatement statement = null;         try {             int index = 1;             statement = prepare(sql);              for (Object bind : toBind) {                 statement.setObject(index, bind);                 index++;             }              ResultSet set = statement.executeQuery();              if (set.next()) {                 Object object = set.getObject(column);                 set.close();                 return object;             }              set.close();         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Get the total amount of protections      * @return the number of protections      */     public int getProtectionCount() {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections\&quot;, \&quot;count\&quot;).toString());     }      /**      * Get the amount of protections for the given protection type      * @param type      * @return the number of protected chests      */     public int getProtectionCount(Protection.Type type) {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections WHERE type = \&quot; + type.ordinal(), \&quot;count\&quot;).toString());     }      /**      * @return the number of history items stored      */     public int getHistoryCount() {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;history\&quot;, \&quot;count\&quot;).toString());     }      /**      * Get the amount of protections a player has      *      * @param player      * @return the amount of protections they have      */     public int getProtectionCount(String player) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) as count FROM \&quot; + prefix + \&quot;protections WHERE owner = ?\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the amount of protections a player has      *      * @param player      * @return the amount of protections they have      */     public int getHistoryCount(String player) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?)\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the amount of chests a player has of a specific block id      *      * @param player      * @return the amount of protections they have of blockId      */     public int getProtectionCount(String player, int blockId) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections WHERE owner = ? AND blockId = ?\&quot;);             statement.setString(1, player);             statement.setInt(2, blockId);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the menu style for a player      *      * @param player      * @return      * @deprecated      */     public String getMenuStyle(String player) {         return \&quot;basic\&quot;;     }      /**      * Load the database and do any updating required or create the tables      */     @Override     public void load() {         if (loaded) {             return;         }          Column column;          Table protections = new Table(this, \&quot;protections\&quot;);         {             column = new Column(\&quot;id\&quot;);             column.setType(\&quot;INTEGER\&quot;);             column.setPrimary(true);             protections.add(column);              column = new Column(\&quot;owner\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;type\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;x\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;y\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;z\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;flags\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;data\&quot;);             column.setType(\&quot;TEXT\&quot;);             protections.add(column);              column = new Column(\&quot;blockId\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;world\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;password\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;date\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;last_accessed\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);         }          Table history = new Table(this, \&quot;history\&quot;);         {             column = new Column(\&quot;id\&quot;);             column.setType(\&quot;INTEGER\&quot;);             column.setPrimary(true);             history.add(column);              column = new Column(\&quot;protectionId\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;player\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             history.add(column);              column = new Column(\&quot;x\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;y\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;z\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;type\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;status\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;metadata\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             history.add(column);              column = new Column(\&quot;timestamp\&quot;);             column.setType(\&quot;long\&quot;);             history.add(column);         }          Table internal = new Table(this, \&quot;internal\&quot;);         {             column = new Column(\&quot;name\&quot;);             column.setType(\&quot;VARCHAR(40)\&quot;);             column.setPrimary(true);             column.setAutoIncrement(false);             internal.add(column);              column = new Column(\&quot;value\&quot;);             column.setType(\&quot;VARCHAR(40)\&quot;);             internal.add(column);         }          protections.execute();         history.execute();         internal.execute();          // Load the database version         loadDatabaseVersion();          // perform database upgrades         performDatabaseUpdates();          // get the amount of protections         protectionCount = getProtectionCount();          loaded = true;     }      /**      * Perform any database updates      */     public void performDatabaseUpdates() {          // Indexes         if (databaseVersion == 0) {             // Drop old, old indexes             log(\&quot;Dropping old indexes (One time, may take a while!)\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in1\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in6\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in7\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in8\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in9\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in10\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in12\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in13\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in14\&quot;);              // Create our updated (good) indexes             log(\&quot;Creating new indexes (One time, may take a while!)\&quot;);             createIndex(\&quot;protections\&quot;, \&quot;protections_main\&quot;, \&quot;x, y, z, world\&quot;);             createIndex(\&quot;protections\&quot;, \&quot;protections_utility\&quot;, \&quot;owner\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_main\&quot;, \&quot;protectionId\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_utility\&quot;, \&quot;player\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_utility2\&quot;, \&quot;x, y, z\&quot;);              // increment the database version             incrementDatabaseVersion();         }          if (databaseVersion == 1) {             log(\&quot;Creating index on internal\&quot;);             createIndex(\&quot;internal\&quot;, \&quot;internal_main\&quot;, \&quot;name\&quot;);             incrementDatabaseVersion();         }          if (databaseVersion == 2) {             incrementDatabaseVersion();         }                  if (databaseVersion == 3) {             createIndex(\&quot;protections\&quot;, \&quot;protections_type\&quot;, \&quot;type\&quot;);             incrementDatabaseVersion();         }      }      /**      * Increment the database version      */     public void incrementDatabaseVersion() {         setDatabaseVersion(++databaseVersion);     }      /**      * Set the database version and sync it to the database      *       * @param databaseVersion      */     public void setDatabaseVersion(int databaseVersion) {         // set it locally         this.databaseVersion = databaseVersion;          // ship it to the database         PreparedStatement statement = null;         try {             statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;internal SET value = ? WHERE name = ?\&quot;);             statement.setInt(1, databaseVersion);             statement.setString(2, \&quot;version\&quot;);              // ok             statement.executeUpdate();         } catch (SQLException e) {          } finally {             safeClose(statement);         }     }      /**      * Get a value in the internal table      *      * @param key      * @return the value found, otherwise NULL if none exists      */     public String getInternal(String key) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT value FROM \&quot; + prefix + \&quot;internal WHERE name = ?\&quot;);             statement.setString(1, key);                          ResultSet set = statement.executeQuery();             if (set.next()) {                 String value = set.getString(\&quot;value\&quot;);                 set.close();                 return value;             }             set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Set a value in the internal table      *      * @param key      * @param value      */     public void setInternal(String key, String value) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;INSERT INTO \&quot; + prefix +\&quot;internal (name, value) VALUES (?, ?)\&quot;);             statement.setString(1, key);             statement.setString(2, value);              statement.executeUpdate();         } catch (SQLException e) {             safeClose(statement);             // Already exists             try {                 PreparedStatement statement2 = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;internal SET value = ? WHERE name = ?\&quot;);                 statement2.setString(1, value) ;                 statement2.setString(2, key);                  statement2.executeUpdate();             } catch (SQLException ex) {                 // Something bad went wrong                 printException(ex);             }         } finally {             safeClose(statement);         }     }      /**      * Load the database internal version      *      * @return      */     public int loadDatabaseVersion() {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT value FROM \&quot; + prefix + \&quot;internal WHERE name = ?\&quot;);             statement.setString(1, \&quot;version\&quot;);              // Execute it             ResultSet set = statement.executeQuery();              // load the version             if (set.next()) {                 databaseVersion = Integer.parseInt(set.getString(\&quot;value\&quot;));             } else {                 throw new IllegalStateException(\&quot;Internal is empty\&quot;);             }              // close everything             set.close();         } catch (Exception e) {             safeClose(statement);             // Doesn't exist, create it             try {                 PreparedStatement statement2 = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;internal (name, value) VALUES(?, ?)\&quot;);                 statement2.setString(1, \&quot;version\&quot;);                 statement2.setInt(2, databaseVersion);                  // ok                 statement2.executeUpdate();                 statement2.close();             } catch (SQLException ex) { }         } finally {             safeClose(statement);         }          return databaseVersion;     }      /**      * Load a protection with the given id      *      * @param id      * @return the Chest object      */     public Protection loadProtection(int id) {         // the protection cache         ProtectionCache cache = LWC.getInstance().getProtectionCache();          // check if the protection is already cached         Protection cached = cache.getProtectionById(id);         if (cached != null) {             return cached;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE id = ?\&quot;);             statement.setInt(1, id);              Protection protection = resolveProtection(statement);              if (protection != null) {                 cache.add(protection);                 return protection;             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load protections using a specific type      *      * @param type      * @return the Protection object      */     public List&lt;Protection&gt; loadProtectionsUsingType(Protection.Type type) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE type = ?\&quot;);             statement.setInt(1, type.ordinal());              return resolveProtections(statement);         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Resolve one protection from a ResultSet. The ResultSet is not closed.      *      * @param set      * @return      */     public Protection resolveProtection(ResultSet set) {         try {             Protection protection = new Protection();              int protectionId = set.getInt(\&quot;id\&quot;);             int x = set.getInt(\&quot;x\&quot;);             int y = set.getInt(\&quot;y\&quot;);             int z = set.getInt(\&quot;z\&quot;);             int blockId = set.getInt(\&quot;blockId\&quot;);             int type = set.getInt(\&quot;type\&quot;);             String world = set.getString(\&quot;world\&quot;);             String owner = set.getString(\&quot;owner\&quot;);             String password = set.getString(\&quot;password\&quot;);             String date = set.getString(\&quot;date\&quot;);             long lastAccessed = set.getLong(\&quot;last_accessed\&quot;);              protection.setId(protectionId);             protection.setX(x);             protection.setY(y);             protection.setZ(z);             protection.setBlockId(blockId);             protection.setType(Protection.Type.values()[type]);             protection.setWorld(world);             protection.setOwner(owner);             protection.setPassword(password);             protection.setCreation(date);             protection.setLastAccessed(lastAccessed);              // check for oh so beautiful data!             String data = set.getString(\&quot;data\&quot;);              if (data == null || data.trim().isEmpty()) {                 return protection;             }              // rev up them JSON parsers!             Object object = null;              try {                 object = jsonParser.parse(data);             } catch (Exception e) {                 return protection;             } catch (Error e) {                 return protection;             }              if (!(object instanceof JSONObject)) {                 return protection;             }              // obtain the root             JSONObject root = (JSONObject) object;             protection.getData().putAll(root);              // Attempt to parse rights             Object rights = root.get(\&quot;rights\&quot;);              if (rights != null &amp;&amp; (rights instanceof JSONArray)) {                 JSONArray array = (JSONArray) rights;                  for (Object node : array) {                     // we only want to use the maps                     if (!(node instanceof JSONObject)) {                         continue;                     }                      JSONObject map = (JSONObject) node;                      // decode the map                     Permission permission = Permission.decodeJSON(map);                      // bingo!                     if (permission != null) {                         protection.addPermission(permission);                     }                 }             }              // Attempt to parse flags             Object flags = root.get(\&quot;flags\&quot;);             if (flags != null &amp;&amp; (rights instanceof JSONArray)) {                 JSONArray array = (JSONArray) flags;                  for (Object node : array) {                     if (!(node instanceof JSONObject)) {                         continue;                     }                      JSONObject map = (JSONObject) node;                      Flag flag = Flag.decodeJSON(map);                      if (flag != null) {                         protection.addFlag(flag);                     }                 }             }              return protection;         } catch (SQLException e) {             printException(e);             return null;         }     }      /**      * Resolve every protection from a result set      *      * @param set      * @return      */     private List&lt;Protection&gt; resolveProtections(ResultSet set) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          try {             while (set.next()) {                 Protection protection = resolveProtection(set);                  if (protection != null) {                     protections.add(protection);                 }             }         } catch (SQLException e) {             printException(e);         }          return protections;     }      /**      * Resolve a list of protections from a statement      *      * @param statement      * @return      */     private List&lt;Protection&gt; resolveProtections(PreparedStatement statement) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();         ResultSet set = null;          try {             set = statement.executeQuery();             protections = resolveProtections(set);         } catch (SQLException e) {             printException(e);         } finally {             if (set != null) {                 try {                     set.close();                 } catch (SQLException e) {                 }             }         }          return protections;     }      /**      * Resolve the first protection from a statement      *      * @param statement      * @return      */     private Protection resolveProtection(PreparedStatement statement) {         List&lt;Protection&gt; protections = resolveProtections(statement);          if (protections.size() == 0) {             return null;         }          return protections.get(0);     }      /**      * Fill the protection cache as much as possible with protections      * Caches the most recent protections      */     public void precache() {         LWC lwc = LWC.getInstance();         ProtectionCache cache = lwc.getProtectionCache();          // clear the cache incase we're working on a dirty cache         cache.clear();          int precacheSize = lwc.getConfiguration().getInt(\&quot;core.precache\&quot;, -1);          if (precacheSize == -1) {             precacheSize = lwc.getConfiguration().getInt(\&quot;core.cacheSize\&quot;, 10000);         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections ORDER BY id DESC LIMIT ?\&quot;);             statement.setInt(1, precacheSize);             statement.setFetchSize(10);              // scrape the protections from the result set now             List&lt;Protection&gt; protections = resolveProtections(statement);              // throw all of the protections in             for (Protection protection : protections) {                 cache.add(protection);             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          // Cache them all     }      /**      * Load a protection at the given coordinates      *      * @param x      * @param y      * @param z      * @return the Protection object      */     public Protection loadProtection(String worldName, int x, int y, int z) {         return loadProtection(worldName, x, y, z, false);     }      /**      * Load a protection at the given coordinates      *      * @param x      * @param y      * @param z      * @param ignoreProtectionCount      * @return the Protection object      */     private Protection loadProtection(String worldName, int x, int y, int z, boolean ignoreProtectionCount) {         // the unique key to use in the cache         String cacheKey = worldName + \&quot;:\&quot; + x + \&quot;:\&quot; + y + \&quot;:\&quot; + z;          // the protection cache         ProtectionCache cache = LWC.getInstance().getProtectionCache();          // check if the protection is already cached         Protection cached = cache.getProtection(cacheKey);         if (cached != null) {             // System.out.println(\&quot;loadProtection() =&gt; CACHE HIT\&quot;);             return cached;         }          // Is it possible that there are protections in the cache?         if (!ignoreProtectionCount &amp;&amp; hasAllProtectionsCached()) {             // System.out.println(\&quot;loadProtection() =&gt; HAS_ALL_PROTECTIONS_CACHED\&quot;);             return null; // nothing was in the cache, nothing assumed to be in the database         }         // System.out.println(\&quot;loadProtection() =&gt; QUERYING\&quot;);          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE x = ? AND y = ? AND z = ? AND world = ?\&quot;);             statement.setInt(1, x);             statement.setInt(2, y);             statement.setInt(3, z);             statement.setString(4, worldName);              Protection protection = resolveProtection(statement);              if (protection != null) {                 // cache the protection                 cache.add(protection);             }              return protection;         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load all protections (use sparingly !!)      *      * @return      */     public List&lt;Protection&gt; loadProtections() {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections\&quot;);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Load the first protection within a block's radius      *      * @param world      * @param x      * @param y      * @param z      * @param radius      * @return list of Protection objects found      */     public List&lt;Protection&gt; loadProtections(String world, int x, int y, int z, int radius) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE world = ? AND x &gt;= ? AND x &lt;= ? AND y &gt;= ? AND y &lt;= ? AND z &gt;= ? AND z &lt;= ?\&quot;);              statement.setString(1, world);             statement.setInt(2, x - radius);             statement.setInt(3, x + radius);             statement.setInt(4, y - radius);             statement.setInt(5, y + radius);             statement.setInt(6, z - radius);             statement.setInt(7, z + radius);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Remove all protections for a given player      *      * @param player      * @return the amount of protections removed      */     public int removeProtectionsByPlayer(String player) {         int removed = 0;          for (Protection protection : loadProtectionsByPlayer(player)) {             protection.remove();             removed ++;         }          return removed;     }      /**      * Load all protections in the coordinate ranges      *      * @param world      * @param x1      * @param x2      * @param y1      * @param y2      * @param z1      * @param z2      * @return list of Protection objects found      */     public List&lt;Protection&gt; loadProtections(String world, int x1, int x2, int y1, int y2, int z1, int z2) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE world = ? AND x &gt;= ? AND x &lt;= ? AND y &gt;= ? AND y &lt;= ? AND z &gt;= ? AND z &lt;= ?\&quot;);              statement.setString(1, world);             statement.setInt(2, x1);             statement.setInt(3, x2);             statement.setInt(4, y1);             statement.setInt(5, y2);             statement.setInt(6, z1);             statement.setInt(7, z2);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Load protections by a player      *      * @param player      * @return      */     public List&lt;Protection&gt; loadProtectionsByPlayer(String player) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE owner = ?\&quot;);             statement.setString(1, player);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return protections;     }      /**      * Load protections by a player      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;Protection&gt; loadProtectionsByPlayer(String player, int start, int count) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE owner = ? ORDER BY id DESC limit ?,?\&quot;);             statement.setString(1, player);             statement.setInt(2, start);             statement.setInt(3, count);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return protections;     }      /**      * Register a protection      *      * @param blockId      * @param type      * @param world      * @param player      * @param data      * @param x      * @param y      * @param z      * @return      */     @Deprecated     public Protection registerProtection(int blockId, int type, String world, String player, String data, int x, int y, int z) {         return registerProtection(blockId, Protection.Type.values()[type], world, player, data, x, y, z);     }      /**      * Register a protection      *      * @param blockId      * @param type      * @param world      * @param player      * @param data      * @param x      * @param y      * @param z      * @return      */     public Protection registerProtection(int blockId, Protection.Type type, String world, String player, String data, int x, int y, int z) {         ProtectionCache cache = LWC.getInstance().getProtectionCache();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;protections (blockId, type, world, owner, password, x, y, z, date, last_accessed) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;);              statement.setInt(1, blockId);             statement.setInt(2, type.ordinal());             statement.setString(3, world);             statement.setString(4, player);             statement.setString(5, data);             statement.setInt(6, x);             statement.setInt(7, y);             statement.setInt(8, z);             statement.setString(9, new Timestamp(new Date().getTime()).toString());             statement.setLong(10, System.currentTimeMillis() / 1000L);              statement.executeUpdate();              // We need to create the initial transaction for this protection             // this transaction is viewable and modifiable during POST_REGISTRATION             Protection protection = loadProtection(world, x, y, z, true);              // if history logging is enabled, create it             if (LWC.getInstance().isHistoryEnabled() &amp;&amp; protection != null) {                 History transaction = protection.createHistoryObject();                  transaction.setPlayer(player);                 transaction.setType(History.Type.TRANSACTION);                 transaction.setStatus(History.Status.ACTIVE);                  // store the player that created the protection                 transaction.addMetaData(\&quot;creator=\&quot; + player);                  // now sync the history object to the database                 transaction.saveNow();             }                          // Cache it             if (protection != null) {                 cache.add(protection);                 protectionCount ++;             }              // return the newly created protection             return protection;         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Sync a History object to the database or save a newly created one      *      * @param history      */     public void saveHistory(History history) {         PreparedStatement statement = null;         try {             if (history.doesExist()) {                 statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;history SET protectionId = ?, player = ?, x = ?, y = ?, z = ?, type = ?, status = ?, metadata = ?, timestamp = ? WHERE id = ?\&quot;);             } else {                 statement = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;history (protectionId, player, x, y, z, type, status, metadata, timestamp) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;, true);                 history.setTimestamp(System.currentTimeMillis() / 1000L);             }              statement.setInt(1, history.getProtectionId());             statement.setString(2, history.getPlayer());             statement.setInt(3, history.getX());             statement.setInt(4, history.getY());             statement.setInt(5, history.getZ());             statement.setInt(6, history.getType().ordinal());             statement.setInt(7, history.getStatus().ordinal());             statement.setString(8, history.getSafeMetaData());             statement.setLong(9, history.getTimestamp());              if (history.doesExist()) {                 statement.setInt(10, history.getId());             }              int affectedRows;              if (statement instanceof AutoClosingPreparedStatement) {                 affectedRows = ((AutoClosingPreparedStatement) statement).executeUpdate(false);             } else {                 affectedRows = statement.executeUpdate();             }              // set the history id if inserting             if (!history.doesExist()) {                 if (affectedRows &gt; 0) {                     ResultSet generatedKeys = statement.getGeneratedKeys();                      // get the key inserted                     if (generatedKeys.next()) {                         history.setId(generatedKeys.getInt(1));                     }                      generatedKeys.close();                 }             }              statement.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Invalid all history objects for a player      *       * @param player      */     public void invalidateHistory(String player) {        try {            PreparedStatement statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;history SET status = ? WHERE Lower(player) = Lower(?)\&quot;);            statement.setInt(1, History.Status.INACTIVE.ordinal());            statement.setString(2, player);             statement.executeUpdate();        } catch (SQLException e) {            printException(e);        }     }      /**      * Resolve 1 history object from the result set but do not close it      *      * @return      */     private History resolveHistory(History history, ResultSet set) throws SQLException {         if (history == null) {             return null;         }          int historyId = set.getInt(\&quot;id\&quot;);         int protectionId = set.getInt(\&quot;protectionId\&quot;);         int x = set.getInt(\&quot;x\&quot;);         int y = set.getInt(\&quot;y\&quot;);         int z = set.getInt(\&quot;z\&quot;);         String player = set.getString(\&quot;player\&quot;);         int type_ord = set.getInt(\&quot;type\&quot;);         int status_ord = set.getInt(\&quot;status\&quot;);         String[] metadata = set.getString(\&quot;metadata\&quot;).split(\&quot;,\&quot;);         long timestamp = set.getLong(\&quot;timestamp\&quot;);          History.Type type = History.Type.values()[type_ord];         History.Status status = History.Status.values()[status_ord];          history.setId(historyId);         history.setProtectionId(protectionId);         history.setType(type);         history.setPlayer(player);         history.setX(x);         history.setY(y);         history.setZ(z);         history.setStatus(status);         history.setMetaData(metadata);         history.setTimestamp(timestamp);          return history;     }      /**      * Load all of the History objects for a given protection      *      * @param protection      * @return      */     public List&lt;History&gt; loadHistory(Protection protection) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE protectionId = ? ORDER BY id DESC\&quot;);             statement.setInt(1, protection.getId());              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(protection.createHistoryObject(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history that the given player created      *      * @param player      * @return      */     public List&lt;History&gt; loadHistory(Player player) {         return loadHistory(player.getName());     }      /**      * Load all protection history that the given player created      *      * @param player      * @return      */     public List&lt;History&gt; loadHistory(String player) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) ORDER BY id DESC\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history that has the given history id      *      * @param historyId      * @return      */     public History loadHistory(int historyId) {         if (!LWC.getInstance().isHistoryEnabled()) {             return null;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE id = ?\&quot;);             statement.setInt(1, historyId);              ResultSet set = statement.executeQuery();              if (set.next()) {                 History history = resolveHistory(new History(), set);                  set.close();                 return history;             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load all protection history that the given player created for a given page, getting count history items.      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;History&gt; loadHistory(Player player, int start, int count) {         return loadHistory(player.getName(), start, count);     }      /**      * Load all protection history that the given player created for a given page, getting count history items.      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;History&gt; loadHistory(String player, int start, int count) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) ORDER BY id DESC LIMIT ?,?\&quot;);             statement.setString(1, player);             statement.setInt(2, start);             statement.setInt(3, count);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history      *      * @return      */     public List&lt;History&gt; loadHistory() {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history ORDER BY\&quot; + id + \&quot;DESC\&quot;);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history for the given status      *      * @return      */     public List&lt;History&gt; loadHistory(History.Status status) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE status = ? ORDER BY id DESC\&quot;);             statement.setInt(1, status.ordinal());             ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all of the history at the given location      *      * @param x      * @param y      * @param z      * @return      */     public List&lt;History&gt; loadHistory(int x, int y, int z) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE x = ? AND y = ? AND z = ?\&quot;);             statement.setInt(1, x);             statement.setInt(2, y);             statement.setInt(3, z);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all of the history at the given location      *      * @param player      * @param x      * @param y      * @param z      * @return      */     public List&lt;History&gt; loadHistory(String player, int x, int y, int z) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) AND x = ? AND y = ? AND z = ?\&quot;);             statement.setString(1, player);             statement.setInt(2, x);             statement.setInt(3, y);             statement.setInt(4, z);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history      *      * @return      */     public List&lt;History&gt; loadHistory(int start, int count) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history ORDER BY id DESC LIMIT ?,?\&quot;);             statement.setInt(1, start);             statement.setInt(2, count);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Save a protection to the database      *      * @param protection      */     public void saveProtection(Protection protection) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;REPLACE INTO \&quot;              \t+ prefix + \&quot;protections (id, type, blockId, world, data, owner, password, x, y, z, date, last_accessed) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;);              statement.setInt(1, protection.getId());             statement.setInt(2, protection.getType().ordinal());             statement.setInt(3, protection.getBlockId());             statement.setString(4, protection.getWorld());             statement.setString(5, protection.getData().toJSONString());             statement.setString(6, protection.getOwner());             statement.setString(7, protection.getPassword());             statement.setInt(8, protection.getX());             statement.setInt(9, protection.getY());             statement.setInt(10, protection.getZ());             statement.setString(11, protection.getCreation());             statement.setLong(12, protection.getLastAccessed());              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Free a chest from protection      *      * @param protectionId the protection Id      */     public void removeProtection(int protectionId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;protections WHERE id = ?\&quot;);             statement.setInt(1, protectionId);              int affected = statement.executeUpdate();              if (affected &gt;= 1) {                 protectionCount -= affected;             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          // removeProtectionHistory(protectionId);     }      public void removeProtectionHistory(int protectionId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;history WHERE protectionId = ?\&quot;);             statement.setInt(1, protectionId);              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      public void removeHistory(int historyId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;history WHERE id = ?\&quot;);             statement.setInt(1, historyId);              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Remove **&lt;b&gt;ALL&lt;/b&gt;** all of the protections registered by LWC      */     public void removeAllProtections() {         try {             Connection connection = createConnection();             Statement statement = connection.createStatement();             statement.executeUpdate(\&quot;DELETE FROM \&quot; + prefix + \&quot;protections\&quot;);             protectionCount = 0;             statement.close();             connection.close();         } catch (SQLException e) {             printException(e);         }     }      /**      * Attempt to create an index on the table      *      * @param table      * @param indexName      * @param columns      */     private void createIndex(String table, String indexName, String columns) {         Connection connection = null;         Statement statement = null;          try {             connection = createConnection();             statement = connection.createStatement();             statement.executeUpdate(\&quot;CREATE INDEX\&quot; + (currentType == Type.SQLite ? \&quot; IF NOT EXISTS\&quot; : \&quot;\&quot;) + \&quot; \&quot; + indexName + \&quot; ON \&quot; + prefix + table + \&quot; (\&quot; + columns + \&quot;)\&quot;);         } catch (Exception e) {         } finally {             if (statement != null) {                 try {                     statement.close();                 } catch (SQLException e) {                 }             }             if (connection != null) {                 try {                     connection.close();                 } catch (SQLException e) {                 }             }         }     }      /**      * Attempt to create an index on the table      *      * @param indexName      */     private void dropIndex(String table, String indexName) {         Connection connection = null;         Statement statement = null;          try {             connection = createConnection();             statement = connection.createStatement();              if (currentType == Type.SQLite) {                 statement.executeUpdate(\&quot;DROP INDEX IF EXISTS \&quot; + indexName);             } else {                 statement.executeUpdate(\&quot;DROP INDEX \&quot; + indexName + \&quot; ON \&quot; + prefix + table);             }         } catch (Exception e) {         } finally {             if (statement != null) {                 try {                     statement.close();                 } catch (SQLException e) {                 }             }             if (connection != null) {                 try {                     connection.close();                 } catch (SQLException e) {                 }             }         }     }  } &quot;</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>&quot;/*  * Copyright 2011 Tyler Blair. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *    1. Redistributions of source code must retain the above copyright notice, this list of  *       conditions and the following disclaimer.  *  *    2. Redistributions in binary form must reproduce the above copyright notice, this list  *       of conditions and the following disclaimer in the documentation and/or other materials  *       provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are those of the  * authors and contributors and should not be interpreted as representing official policies,  * either expressed or implied, of anybody else.  */  package com.griefcraft.sql;  import com.griefcraft.cache.ProtectionCache; import com.griefcraft.lwc.LWC; import com.griefcraft.model.Flag; import com.griefcraft.model.History; import com.griefcraft.model.Permission; import com.griefcraft.model.Protection; import org.bukkit.entity.Player; import org.json.simple.JSONArray; import org.json.simple.JSONObject; import org.json.simple.parser.JSONParser;  import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.sql.Timestamp; import java.util.ArrayList; import java.util.Date; import java.util.List;  public class PhysDB extends Database {      /**      * The JSON Parser object      */     private final JSONParser jsonParser = new JSONParser();      /**      * The database version      */     private int databaseVersion = 0;      /**      * The number of protections that should exist      */     private int protectionCount = 0;      public PhysDB() {         super();     }      public PhysDB(Type currentType) {         super(currentType);     }      /**      * Decrement the known protection counter      */     public void decrementProtectionCount() {         protectionCount --;     }      /**      * Check if the protection cache has all of the known protections cached      *      * @return      */     public boolean hasAllProtectionsCached() {         ProtectionCache cache = LWC.getInstance().getProtectionCache();          return cache.size() &gt;= protectionCount;     }      /**      * Fetch an object from the sql database      *      * @param sql      * @param column      * @return      */     private Object fetch(String sql, String column, Object... toBind) {         PreparedStatement statement = null;         try {             int index = 1;             statement = prepare(sql);              for (Object bind : toBind) {                 statement.setObject(index, bind);                 index++;             }              ResultSet set = statement.executeQuery();              if (set.next()) {                 Object object = set.getObject(column);                 set.close();                 return object;             }              set.close();         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Get the total amount of protections      * @return the number of protections      */     public int getProtectionCount() {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections\&quot;, \&quot;count\&quot;).toString());     }      /**      * Get the amount of protections for the given protection type      * @param type      * @return the number of protected chests      */     public int getProtectionCount(Protection.Type type) {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections WHERE type = \&quot; + type.ordinal(), \&quot;count\&quot;).toString());     }      /**      * @return the number of history items stored      */     public int getHistoryCount() {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;history\&quot;, \&quot;count\&quot;).toString());     }      /**      * Get the amount of protections a player has      *      * @param player      * @return the amount of protections they have      */     public int getProtectionCount(String player) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) as count FROM \&quot; + prefix + \&quot;protections WHERE owner = ?\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the amount of protections a player has      *      * @param player      * @return the amount of protections they have      */     public int getHistoryCount(String player) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?)\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the amount of chests a player has of a specific block id      *      * @param player      * @return the amount of protections they have of blockId      */     public int getProtectionCount(String player, int blockId) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections WHERE owner = ? AND blockId = ?\&quot;);             statement.setString(1, player);             statement.setInt(2, blockId);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the menu style for a player      *      * @param player      * @return      * @deprecated      */     public String getMenuStyle(String player) {         return \&quot;basic\&quot;;     }      /**      * Load the database and do any updating required or create the tables      */     @Override     public void load() {         if (loaded) {             return;         }          Column column;          Table protections = new Table(this, \&quot;protections\&quot;);         {             column = new Column(\&quot;id\&quot;);             column.setType(\&quot;INTEGER\&quot;);             column.setPrimary(true);             protections.add(column);              column = new Column(\&quot;owner\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;type\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;x\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;y\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;z\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;flags\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;data\&quot;);             column.setType(\&quot;TEXT\&quot;);             protections.add(column);              column = new Column(\&quot;blockId\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;world\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;password\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;date\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;last_accessed\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);         }          Table history = new Table(this, \&quot;history\&quot;);         {             column = new Column(\&quot;id\&quot;);             column.setType(\&quot;INTEGER\&quot;);             column.setPrimary(true);             history.add(column);              column = new Column(\&quot;protectionId\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;player\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             history.add(column);              column = new Column(\&quot;x\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;y\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;z\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;type\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;status\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;metadata\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             history.add(column);              column = new Column(\&quot;timestamp\&quot;);             column.setType(\&quot;long\&quot;);             history.add(column);         }          Table internal = new Table(this, \&quot;internal\&quot;);         {             column = new Column(\&quot;name\&quot;);             column.setType(\&quot;VARCHAR(40)\&quot;);             column.setPrimary(true);             column.setAutoIncrement(false);             internal.add(column);              column = new Column(\&quot;value\&quot;);             column.setType(\&quot;VARCHAR(40)\&quot;);             internal.add(column);         }          protections.execute();         history.execute();         internal.execute();          // Load the database version         loadDatabaseVersion();          // perform database upgrades         performDatabaseUpdates();          // get the amount of protections         protectionCount = getProtectionCount();          loaded = true;     }      /**      * Perform any database updates      */     public void performDatabaseUpdates() {          // Indexes         if (databaseVersion == 0) {             // Drop old, old indexes             log(\&quot;Dropping old indexes (One time, may take a while!)\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in1\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in6\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in7\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in8\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in9\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in10\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in12\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in13\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in14\&quot;);              // Create our updated (good) indexes             log(\&quot;Creating new indexes (One time, may take a while!)\&quot;);             createIndex(\&quot;protections\&quot;, \&quot;protections_main\&quot;, \&quot;x, y, z, world\&quot;);             createIndex(\&quot;protections\&quot;, \&quot;protections_utility\&quot;, \&quot;owner\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_main\&quot;, \&quot;protectionId\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_utility\&quot;, \&quot;player\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_utility2\&quot;, \&quot;x, y, z\&quot;);              // increment the database version             incrementDatabaseVersion();         }          if (databaseVersion == 1) {             log(\&quot;Creating index on internal\&quot;);             createIndex(\&quot;internal\&quot;, \&quot;internal_main\&quot;, \&quot;name\&quot;);             incrementDatabaseVersion();         }          if (databaseVersion == 2) {             incrementDatabaseVersion();         }                  if (databaseVersion == 3) {             createIndex(\&quot;protections\&quot;, \&quot;protections_type\&quot;, \&quot;type\&quot;);             incrementDatabaseVersion();         }      }      /**      * Increment the database version      */     public void incrementDatabaseVersion() {         setDatabaseVersion(++databaseVersion);     }      /**      * Set the database version and sync it to the database      *       * @param databaseVersion      */     public void setDatabaseVersion(int databaseVersion) {         // set it locally         this.databaseVersion = databaseVersion;          // ship it to the database         PreparedStatement statement = null;         try {             statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;internal SET value = ? WHERE name = ?\&quot;);             statement.setInt(1, databaseVersion);             statement.setString(2, \&quot;version\&quot;);              // ok             statement.executeUpdate();         } catch (SQLException e) {          } finally {             safeClose(statement);         }     }      /**      * Get a value in the internal table      *      * @param key      * @return the value found, otherwise NULL if none exists      */     public String getInternal(String key) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT value FROM \&quot; + prefix + \&quot;internal WHERE name = ?\&quot;);             statement.setString(1, key);                          ResultSet set = statement.executeQuery();             if (set.next()) {                 String value = set.getString(\&quot;value\&quot;);                 set.close();                 return value;             }             set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Set a value in the internal table      *      * @param key      * @param value      */     public void setInternal(String key, String value) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;INSERT INTO \&quot; + prefix +\&quot;internal (name, value) VALUES (?, ?)\&quot;);             statement.setString(1, key);             statement.setString(2, value);              statement.executeUpdate();         } catch (SQLException e) {             safeClose(statement);             // Already exists             try {                 PreparedStatement statement2 = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;internal SET value = ? WHERE name = ?\&quot;);                 statement2.setString(1, value) ;                 statement2.setString(2, key);                  statement2.executeUpdate();             } catch (SQLException ex) {                 // Something bad went wrong                 printException(ex);             }         } finally {             safeClose(statement);         }     }      /**      * Load the database internal version      *      * @return      */     public int loadDatabaseVersion() {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT value FROM \&quot; + prefix + \&quot;internal WHERE name = ?\&quot;);             statement.setString(1, \&quot;version\&quot;);              // Execute it             ResultSet set = statement.executeQuery();              // load the version             if (set.next()) {                 databaseVersion = Integer.parseInt(set.getString(\&quot;value\&quot;));             } else {                 throw new IllegalStateException(\&quot;Internal is empty\&quot;);             }              // close everything             set.close();         } catch (Exception e) {             safeClose(statement);             // Doesn't exist, create it             try {                 PreparedStatement statement2 = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;internal (name, value) VALUES(?, ?)\&quot;);                 statement2.setString(1, \&quot;version\&quot;);                 statement2.setInt(2, databaseVersion);                  // ok                 statement2.executeUpdate();                 statement2.close();             } catch (SQLException ex) { }         } finally {             safeClose(statement);         }          return databaseVersion;     }      /**      * Load a protection with the given id      *      * @param id      * @return the Chest object      */     public Protection loadProtection(int id) {         // the protection cache         ProtectionCache cache = LWC.getInstance().getProtectionCache();          // check if the protection is already cached         Protection cached = cache.getProtectionById(id);         if (cached != null) {             return cached;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE id = ?\&quot;);             statement.setInt(1, id);              Protection protection = resolveProtection(statement);              if (protection != null) {                 cache.add(protection);                 return protection;             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load protections using a specific type      *      * @param type      * @return the Protection object      */     public List&lt;Protection&gt; loadProtectionsUsingType(Protection.Type type) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE type = ?\&quot;);             statement.setInt(1, type.ordinal());              return resolveProtections(statement);         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Resolve one protection from a ResultSet. The ResultSet is not closed.      *      * @param set      * @return      */     public Protection resolveProtection(ResultSet set) {         try {             Protection protection = new Protection();              int protectionId = set.getInt(\&quot;id\&quot;);             int x = set.getInt(\&quot;x\&quot;);             int y = set.getInt(\&quot;y\&quot;);             int z = set.getInt(\&quot;z\&quot;);             int blockId = set.getInt(\&quot;blockId\&quot;);             int type = set.getInt(\&quot;type\&quot;);             String world = set.getString(\&quot;world\&quot;);             String owner = set.getString(\&quot;owner\&quot;);             String password = set.getString(\&quot;password\&quot;);             String date = set.getString(\&quot;date\&quot;);             long lastAccessed = set.getLong(\&quot;last_accessed\&quot;);              protection.setId(protectionId);             protection.setX(x);             protection.setY(y);             protection.setZ(z);             protection.setBlockId(blockId);             protection.setType(Protection.Type.values()[type]);             protection.setWorld(world);             protection.setOwner(owner);             protection.setPassword(password);             protection.setCreation(date);             protection.setLastAccessed(lastAccessed);              // check for oh so beautiful data!             String data = set.getString(\&quot;data\&quot;);              if (data == null || data.trim().isEmpty()) {                 return protection;             }              // rev up them JSON parsers!             Object object = null;              try {                 object = jsonParser.parse(data);             } catch (Exception e) {                 return protection;             } catch (Error e) {                 return protection;             }              if (!(object instanceof JSONObject)) {                 return protection;             }              // obtain the root             JSONObject root = (JSONObject) object;             protection.getData().putAll(root);              // Attempt to parse rights             Object rights = root.get(\&quot;rights\&quot;);              if (rights != null &amp;&amp; (rights instanceof JSONArray)) {                 JSONArray array = (JSONArray) rights;                  for (Object node : array) {                     // we only want to use the maps                     if (!(node instanceof JSONObject)) {                         continue;                     }                      JSONObject map = (JSONObject) node;                      // decode the map                     Permission permission = Permission.decodeJSON(map);                      // bingo!                     if (permission != null) {                         protection.addPermission(permission);                     }                 }             }              // Attempt to parse flags             Object flags = root.get(\&quot;flags\&quot;);             if (flags != null &amp;&amp; (rights instanceof JSONArray)) {                 JSONArray array = (JSONArray) flags;                  for (Object node : array) {                     if (!(node instanceof JSONObject)) {                         continue;                     }                      JSONObject map = (JSONObject) node;                      Flag flag = Flag.decodeJSON(map);                      if (flag != null) {                         protection.addFlag(flag);                     }                 }             }              return protection;         } catch (SQLException e) {             printException(e);             return null;         }     }      /**      * Resolve every protection from a result set      *      * @param set      * @return      */     private List&lt;Protection&gt; resolveProtections(ResultSet set) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          try {             while (set.next()) {                 Protection protection = resolveProtection(set);                  if (protection != null) {                     protections.add(protection);                 }             }         } catch (SQLException e) {             printException(e);         }          return protections;     }      /**      * Resolve a list of protections from a statement      *      * @param statement      * @return      */     private List&lt;Protection&gt; resolveProtections(PreparedStatement statement) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();         ResultSet set = null;          try {             set = statement.executeQuery();             protections = resolveProtections(set);         } catch (SQLException e) {             printException(e);         } finally {             if (set != null) {                 try {                     set.close();                 } catch (SQLException e) {                 }             }         }          return protections;     }      /**      * Resolve the first protection from a statement      *      * @param statement      * @return      */     private Protection resolveProtection(PreparedStatement statement) {         List&lt;Protection&gt; protections = resolveProtections(statement);          if (protections.size() == 0) {             return null;         }          return protections.get(0);     }      /**      * Fill the protection cache as much as possible with protections      * Caches the most recent protections      */     public void precache() {         LWC lwc = LWC.getInstance();         ProtectionCache cache = lwc.getProtectionCache();          // clear the cache incase we're working on a dirty cache         cache.clear();          int precacheSize = lwc.getConfiguration().getInt(\&quot;core.precache\&quot;, -1);          if (precacheSize == -1) {             precacheSize = lwc.getConfiguration().getInt(\&quot;core.cacheSize\&quot;, 10000);         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections ORDER BY id DESC LIMIT ?\&quot;);             statement.setInt(1, precacheSize);             statement.setFetchSize(10);              // scrape the protections from the result set now             List&lt;Protection&gt; protections = resolveProtections(statement);              // throw all of the protections in             for (Protection protection : protections) {                 cache.add(protection);             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          // Cache them all     }      /**      * Load a protection at the given coordinates      *      * @param x      * @param y      * @param z      * @return the Protection object      */     public Protection loadProtection(String worldName, int x, int y, int z) {         return loadProtection(worldName, x, y, z, false);     }      /**      * Load a protection at the given coordinates      *      * @param x      * @param y      * @param z      * @param ignoreProtectionCount      * @return the Protection object      */     private Protection loadProtection(String worldName, int x, int y, int z, boolean ignoreProtectionCount) {         // the unique key to use in the cache         String cacheKey = worldName + \&quot;:\&quot; + x + \&quot;:\&quot; + y + \&quot;:\&quot; + z;          // the protection cache         ProtectionCache cache = LWC.getInstance().getProtectionCache();          // check if the protection is already cached         Protection cached = cache.getProtection(cacheKey);         if (cached != null) {             // System.out.println(\&quot;loadProtection() =&gt; CACHE HIT\&quot;);             return cached;         }          // Is it possible that there are protections in the cache?         if (!ignoreProtectionCount &amp;&amp; hasAllProtectionsCached()) {             // System.out.println(\&quot;loadProtection() =&gt; HAS_ALL_PROTECTIONS_CACHED\&quot;);             return null; // nothing was in the cache, nothing assumed to be in the database         }         // System.out.println(\&quot;loadProtection() =&gt; QUERYING\&quot;);          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE x = ? AND y = ? AND z = ? AND world = ?\&quot;);             statement.setInt(1, x);             statement.setInt(2, y);             statement.setInt(3, z);             statement.setString(4, worldName);              Protection protection = resolveProtection(statement);              if (protection != null) {                 // cache the protection                 cache.add(protection);             }              return protection;         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load all protections (use sparingly !!)      *      * @return      */     public List&lt;Protection&gt; loadProtections() {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections\&quot;);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Load the first protection within a block's radius      *      * @param world      * @param x      * @param y      * @param z      * @param radius      * @return list of Protection objects found      */     public List&lt;Protection&gt; loadProtections(String world, int x, int y, int z, int radius) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE world = ? AND x &gt;= ? AND x &lt;= ? AND y &gt;= ? AND y &lt;= ? AND z &gt;= ? AND z &lt;= ?\&quot;);              statement.setString(1, world);             statement.setInt(2, x - radius);             statement.setInt(3, x + radius);             statement.setInt(4, y - radius);             statement.setInt(5, y + radius);             statement.setInt(6, z - radius);             statement.setInt(7, z + radius);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Remove all protections for a given player      *      * @param player      * @return the amount of protections removed      */     public int removeProtectionsByPlayer(String player) {         int removed = 0;          for (Protection protection : loadProtectionsByPlayer(player)) {             protection.remove();             removed ++;         }          return removed;     }      /**      * Load all protections in the coordinate ranges      *      * @param world      * @param x1      * @param x2      * @param y1      * @param y2      * @param z1      * @param z2      * @return list of Protection objects found      */     public List&lt;Protection&gt; loadProtections(String world, int x1, int x2, int y1, int y2, int z1, int z2) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE world = ? AND x &gt;= ? AND x &lt;= ? AND y &gt;= ? AND y &lt;= ? AND z &gt;= ? AND z &lt;= ?\&quot;);              statement.setString(1, world);             statement.setInt(2, x1);             statement.setInt(3, x2);             statement.setInt(4, y1);             statement.setInt(5, y2);             statement.setInt(6, z1);             statement.setInt(7, z2);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Load protections by a player      *      * @param player      * @return      */     public List&lt;Protection&gt; loadProtectionsByPlayer(String player) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE owner = ?\&quot;);             statement.setString(1, player);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return protections;     }      /**      * Load protections by a player      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;Protection&gt; loadProtectionsByPlayer(String player, int start, int count) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE owner = ? ORDER BY id DESC limit ?,?\&quot;);             statement.setString(1, player);             statement.setInt(2, start);             statement.setInt(3, count);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return protections;     }      /**      * Register a protection      *      * @param blockId      * @param type      * @param world      * @param player      * @param data      * @param x      * @param y      * @param z      * @return      */     @Deprecated     public Protection registerProtection(int blockId, int type, String world, String player, String data, int x, int y, int z) {         return registerProtection(blockId, Protection.Type.values()[type], world, player, data, x, y, z);     }      /**      * Register a protection      *      * @param blockId      * @param type      * @param world      * @param player      * @param data      * @param x      * @param y      * @param z      * @return      */     public Protection registerProtection(int blockId, Protection.Type type, String world, String player, String data, int x, int y, int z) {         ProtectionCache cache = LWC.getInstance().getProtectionCache();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;protections (blockId, type, world, owner, password, x, y, z, date, last_accessed) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;);              statement.setInt(1, blockId);             statement.setInt(2, type.ordinal());             statement.setString(3, world);             statement.setString(4, player);             statement.setString(5, data);             statement.setInt(6, x);             statement.setInt(7, y);             statement.setInt(8, z);             statement.setString(9, new Timestamp(new Date().getTime()).toString());             statement.setLong(10, System.currentTimeMillis() / 1000L);              statement.executeUpdate();              // We need to create the initial transaction for this protection             // this transaction is viewable and modifiable during POST_REGISTRATION             Protection protection = loadProtection(world, x, y, z, true);              // if history logging is enabled, create it             if (LWC.getInstance().isHistoryEnabled() &amp;&amp; protection != null) {                 History transaction = protection.createHistoryObject();                  transaction.setPlayer(player);                 transaction.setType(History.Type.TRANSACTION);                 transaction.setStatus(History.Status.ACTIVE);                  // store the player that created the protection                 transaction.addMetaData(\&quot;creator=\&quot; + player);                  // now sync the history object to the database                 transaction.saveNow();             }                          // Cache it             if (protection != null) {                 cache.add(protection);                 protectionCount ++;             }              // return the newly created protection             return protection;         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Sync a History object to the database or save a newly created one      *      * @param history      */     public void saveHistory(History history) {         PreparedStatement statement = null;         try {             if (history.doesExist()) {                 statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;history SET protectionId = ?, player = ?, x = ?, y = ?, z = ?, type = ?, status = ?, metadata = ?, timestamp = ? WHERE id = ?\&quot;);             } else {                 statement = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;history (protectionId, player, x, y, z, type, status, metadata, timestamp) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;, true);                 history.setTimestamp(System.currentTimeMillis() / 1000L);             }              statement.setInt(1, history.getProtectionId());             statement.setString(2, history.getPlayer());             statement.setInt(3, history.getX());             statement.setInt(4, history.getY());             statement.setInt(5, history.getZ());             statement.setInt(6, history.getType().ordinal());             statement.setInt(7, history.getStatus().ordinal());             statement.setString(8, history.getSafeMetaData());             statement.setLong(9, history.getTimestamp());              if (history.doesExist()) {                 statement.setInt(10, history.getId());             }              int affectedRows;              if (statement instanceof AutoClosingPreparedStatement) {                 affectedRows = ((AutoClosingPreparedStatement) statement).executeUpdate(false);             } else {                 affectedRows = statement.executeUpdate();             }              // set the history id if inserting             if (!history.doesExist()) {                 if (affectedRows &gt; 0) {                     ResultSet generatedKeys = statement.getGeneratedKeys();                      // get the key inserted                     if (generatedKeys.next()) {                         history.setId(generatedKeys.getInt(1));                     }                      generatedKeys.close();                 }             }              statement.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Invalid all history objects for a player      *       * @param player      */     public void invalidateHistory(String player) {        try {            PreparedStatement statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;history SET status = ? WHERE Lower(player) = Lower(?)\&quot;);            statement.setInt(1, History.Status.INACTIVE.ordinal());            statement.setString(2, player);             statement.executeUpdate();        } catch (SQLException e) {            printException(e);        }     }      /**      * Resolve 1 history object from the result set but do not close it      *      * @return      */     private History resolveHistory(History history, ResultSet set) throws SQLException {         if (history == null) {             return null;         }          int historyId = set.getInt(\&quot;id\&quot;);         int protectionId = set.getInt(\&quot;protectionId\&quot;);         int x = set.getInt(\&quot;x\&quot;);         int y = set.getInt(\&quot;y\&quot;);         int z = set.getInt(\&quot;z\&quot;);         String player = set.getString(\&quot;player\&quot;);         int type_ord = set.getInt(\&quot;type\&quot;);         int status_ord = set.getInt(\&quot;status\&quot;);         String[] metadata = set.getString(\&quot;metadata\&quot;).split(\&quot;,\&quot;);         long timestamp = set.getLong(\&quot;timestamp\&quot;);          History.Type type = History.Type.values()[type_ord];         History.Status status = History.Status.values()[status_ord];          history.setId(historyId);         history.setProtectionId(protectionId);         history.setType(type);         history.setPlayer(player);         history.setX(x);         history.setY(y);         history.setZ(z);         history.setStatus(status);         history.setMetaData(metadata);         history.setTimestamp(timestamp);          return history;     }      /**      * Load all of the History objects for a given protection      *      * @param protection      * @return      */     public List&lt;History&gt; loadHistory(Protection protection) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE protectionId = ? ORDER BY id DESC\&quot;);             statement.setInt(1, protection.getId());              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(protection.createHistoryObject(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history that the given player created      *      * @param player      * @return      */     public List&lt;History&gt; loadHistory(Player player) {         return loadHistory(player.getName());     }      /**      * Load all protection history that the given player created      *      * @param player      * @return      */     public List&lt;History&gt; loadHistory(String player) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) ORDER BY id DESC\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history that has the given history id      *      * @param historyId      * @return      */     public History loadHistory(int historyId) {         if (!LWC.getInstance().isHistoryEnabled()) {             return null;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE id = ?\&quot;);             statement.setInt(1, historyId);              ResultSet set = statement.executeQuery();              if (set.next()) {                 History history = resolveHistory(new History(), set);                  set.close();                 return history;             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load all protection history that the given player created for a given page, getting count history items.      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;History&gt; loadHistory(Player player, int start, int count) {         return loadHistory(player.getName(), start, count);     }      /**      * Load all protection history that the given player created for a given page, getting count history items.      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;History&gt; loadHistory(String player, int start, int count) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) ORDER BY id DESC LIMIT ?,?\&quot;);             statement.setString(1, player);             statement.setInt(2, start);             statement.setInt(3, count);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history      *      * @return      */     public List&lt;History&gt; loadHistory() {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {                   statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history order By\&quot; + id + \&quot;DESC\&quot;);             ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history for the given status      *      * @return      */     public List&lt;History&gt; loadHistory(History.Status status) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE status = ? ORDER BY id DESC\&quot;);             statement.setInt(1, status.ordinal());             ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all of the history at the given location      *      * @param x      * @param y      * @param z      * @return      */     public List&lt;History&gt; loadHistory(int x, int y, int z) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE x = ? AND y = ? AND z = ?\&quot;);             statement.setInt(1, x);             statement.setInt(2, y);             statement.setInt(3, z);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all of the history at the given location      *      * @param player      * @param x      * @param y      * @param z      * @return      */     public List&lt;History&gt; loadHistory(String player, int x, int y, int z) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) AND x = ? AND y = ? AND z = ?\&quot;);             statement.setString(1, player);             statement.setInt(2, x);             statement.setInt(3, y);             statement.setInt(4, z);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history      *      * @return      */     public List&lt;History&gt; loadHistory(int start, int count) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history ORDER BY id DESC LIMIT ?,?\&quot;);             statement.setInt(1, start);             statement.setInt(2, count);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Save a protection to the database      *      * @param protection      */     public void saveProtection(Protection protection) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;REPLACE INTO \&quot;              \t+ prefix + \&quot;protections (id, type, blockId, world, data, owner, password, x, y, z, date, last_accessed) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;);              statement.setInt(1, protection.getId());             statement.setInt(2, protection.getType().ordinal());             statement.setInt(3, protection.getBlockId());             statement.setString(4, protection.getWorld());             statement.setString(5, protection.getData().toJSONString());             statement.setString(6, protection.getOwner());             statement.setString(7, protection.getPassword());             statement.setInt(8, protection.getX());             statement.setInt(9, protection.getY());             statement.setInt(10, protection.getZ());             statement.setString(11, protection.getCreation());             statement.setLong(12, protection.getLastAccessed());              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Free a chest from protection      *      * @param protectionId the protection Id      */     public void removeProtection(int protectionId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;protections WHERE id = ?\&quot;);             statement.setInt(1, protectionId);              int affected = statement.executeUpdate();              if (affected &gt;= 1) {                 protectionCount -= affected;             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          // removeProtectionHistory(protectionId);     }      public void removeProtectionHistory(int protectionId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;history WHERE protectionId = ?\&quot;);             statement.setInt(1, protectionId);              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      public void removeHistory(int historyId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;history WHERE id = ?\&quot;);             statement.setInt(1, historyId);              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Remove **&lt;b&gt;ALL&lt;/b&gt;** all of the protections registered by LWC      */     public void removeAllProtections() {         try {             Connection connection = createConnection();             Statement statement = connection.createStatement();             statement.executeUpdate(\&quot;DELETE FROM \&quot; + prefix + \&quot;protections\&quot;);             protectionCount = 0;             statement.close();             connection.close();         } catch (SQLException e) {             printException(e);         }     }      /**      * Attempt to create an index on the table      *      * @param table      * @param indexName      * @param columns      */     private void createIndex(String table, String indexName, String columns) {         Connection connection = null;         Statement statement = null;          try {             connection = createConnection();             statement = connection.createStatement();             statement.executeUpdate(\&quot;CREATE INDEX\&quot; + (currentType == Type.SQLite ? \&quot; IF NOT EXISTS\&quot; : \&quot;\&quot;) + \&quot; \&quot; + indexName + \&quot; ON \&quot; + prefix + table + \&quot; (\&quot; + columns + \&quot;)\&quot;);         } catch (Exception e) {         } finally {             if (statement != null) {                 try {                     statement.close();                 } catch (SQLException e) {                 }             }             if (connection != null) {                 try {                     connection.close();                 } catch (SQLException e) {                 }             }         }     }      /**      * Attempt to create an index on the table      *      * @param indexName      */     private void dropIndex(String table, String indexName) {         Connection connection = null;         Statement statement = null;          try {             connection = createConnection();             statement = connection.createStatement();              if (currentType == Type.SQLite) {                 statement.executeUpdate(\&quot;DROP INDEX IF EXISTS \&quot; + indexName);             } else {                 statement.executeUpdate(\&quot;DROP INDEX \&quot; + indexName + \&quot; ON \&quot; + prefix + table);             }         } catch (Exception e) {         } finally {             if (statement != null) {                 try {                     statement.close();                 } catch (SQLException e) {                 }             }             if (connection != null) {                 try {                     connection.close();                 } catch (SQLException e) {                 }             }         }     }  } &quot;</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>&quot;/*  * Copyright 2011 Tyler Blair. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *    1. Redistributions of source code must retain the above copyright notice, this list of  *       conditions and the following disclaimer.  *  *    2. Redistributions in binary form must reproduce the above copyright notice, this list  *       of conditions and the following disclaimer in the documentation and/or other materials  *       provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are those of the  * authors and contributors and should not be interpreted as representing official policies,  * either expressed or implied, of anybody else.  */  package com.griefcraft.sql;  import com.griefcraft.cache.ProtectionCache; import com.griefcraft.lwc.LWC; import com.griefcraft.model.Flag; import com.griefcraft.model.History; import com.griefcraft.model.Permission; import com.griefcraft.model.Protection; import org.bukkit.entity.Player; import org.json.simple.JSONArray; import org.json.simple.JSONObject; import org.json.simple.parser.JSONParser;  import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.sql.Timestamp; import java.util.ArrayList; import java.util.Date; import java.util.List;  public class PhysDB extends Database {      /**      * The JSON Parser object      */     private final JSONParser jsonParser = new JSONParser();      /**      * The database version      */     private int databaseVersion = 0;      /**      * The number of protections that should exist      */     private int protectionCount = 0;      public PhysDB() {         super();     }      public PhysDB(Type currentType) {         super(currentType);     }      /**      * Decrement the known protection counter      */     public void decrementProtectionCount() {         protectionCount --;     }      /**      * Check if the protection cache has all of the known protections cached      *      * @return      */     public boolean hasAllProtectionsCached() {         ProtectionCache cache = LWC.getInstance().getProtectionCache();          return cache.size() &gt;= protectionCount;     }      /**      * Fetch an object from the sql database      *      * @param sql      * @param column      * @return      */     private Object fetch(String sql, String column, Object... toBind) {         PreparedStatement statement = null;         try {             int index = 1;             statement = prepare(sql);              for (Object bind : toBind) {                 statement.setObject(index, bind);                 index++;             }              ResultSet set = statement.executeQuery();              if (set.next()) {                 Object object = set.getObject(column);                 set.close();                 return object;             }              set.close();         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Get the total amount of protections      * @return the number of protections      */     public int getProtectionCount() {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections\&quot;, \&quot;count\&quot;).toString());     }      /**      * Get the amount of protections for the given protection type      * @param type      * @return the number of protected chests      */     public int getProtectionCount(Protection.Type type) {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections WHERE type = \&quot; + type.ordinal(), \&quot;count\&quot;).toString());     }      /**      * @return the number of history items stored      */     public int getHistoryCount() {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;history\&quot;, \&quot;count\&quot;).toString());     }      /**      * Get the amount of protections a player has      *      * @param player      * @return the amount of protections they have      */     public int getProtectionCount(String player) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) as count FROM \&quot; + prefix + \&quot;protections WHERE owner = ?\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the amount of protections a player has      *      * @param player      * @return the amount of protections they have      */     public int getHistoryCount(String player) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?)\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the amount of chests a player has of a specific block id      *      * @param player      * @return the amount of protections they have of blockId      */     public int getProtectionCount(String player, int blockId) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections WHERE owner = ? AND blockId = ?\&quot;);             statement.setString(1, player);             statement.setInt(2, blockId);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the menu style for a player      *      * @param player      * @return      * @deprecated      */     public String getMenuStyle(String player) {         return \&quot;basic\&quot;;     }      /**      * Load the database and do any updating required or create the tables      */     @Override     public void load() {         if (loaded) {             return;         }          Column column;          Table protections = new Table(this, \&quot;protections\&quot;);         {             column = new Column(\&quot;id\&quot;);             column.setType(\&quot;INTEGER\&quot;);             column.setPrimary(true);             protections.add(column);              column = new Column(\&quot;owner\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;type\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;x\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;y\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;z\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;flags\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;data\&quot;);             column.setType(\&quot;TEXT\&quot;);             protections.add(column);              column = new Column(\&quot;blockId\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;world\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;password\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;date\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;last_accessed\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);         }          Table history = new Table(this, \&quot;history\&quot;);         {             column = new Column(\&quot;id\&quot;);             column.setType(\&quot;INTEGER\&quot;);             column.setPrimary(true);             history.add(column);              column = new Column(\&quot;protectionId\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;player\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             history.add(column);              column = new Column(\&quot;x\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;y\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;z\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;type\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;status\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;metadata\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             history.add(column);              column = new Column(\&quot;timestamp\&quot;);             column.setType(\&quot;long\&quot;);             history.add(column);         }          Table internal = new Table(this, \&quot;internal\&quot;);         {             column = new Column(\&quot;name\&quot;);             column.setType(\&quot;VARCHAR(40)\&quot;);             column.setPrimary(true);             column.setAutoIncrement(false);             internal.add(column);              column = new Column(\&quot;value\&quot;);             column.setType(\&quot;VARCHAR(40)\&quot;);             internal.add(column);         }          protections.execute();         history.execute();         internal.execute();          // Load the database version         loadDatabaseVersion();          // perform database upgrades         performDatabaseUpdates();          // get the amount of protections         protectionCount = getProtectionCount();          loaded = true;     }      /**      * Perform any database updates      */     public void performDatabaseUpdates() {          // Indexes         if (databaseVersion == 0) {             // Drop old, old indexes             log(\&quot;Dropping old indexes (One time, may take a while!)\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in1\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in6\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in7\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in8\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in9\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in10\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in12\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in13\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in14\&quot;);              // Create our updated (good) indexes             log(\&quot;Creating new indexes (One time, may take a while!)\&quot;);             createIndex(\&quot;protections\&quot;, \&quot;protections_main\&quot;, \&quot;x, y, z, world\&quot;);             createIndex(\&quot;protections\&quot;, \&quot;protections_utility\&quot;, \&quot;owner\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_main\&quot;, \&quot;protectionId\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_utility\&quot;, \&quot;player\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_utility2\&quot;, \&quot;x, y, z\&quot;);              // increment the database version             incrementDatabaseVersion();         }          if (databaseVersion == 1) {             log(\&quot;Creating index on internal\&quot;);             createIndex(\&quot;internal\&quot;, \&quot;internal_main\&quot;, \&quot;name\&quot;);             incrementDatabaseVersion();         }          if (databaseVersion == 2) {             incrementDatabaseVersion();         }                  if (databaseVersion == 3) {             createIndex(\&quot;protections\&quot;, \&quot;protections_type\&quot;, \&quot;type\&quot;);             incrementDatabaseVersion();         }      }      /**      * Increment the database version      */     public void incrementDatabaseVersion() {         setDatabaseVersion(++databaseVersion);     }      /**      * Set the database version and sync it to the database      *       * @param databaseVersion      */     public void setDatabaseVersion(int databaseVersion) {         // set it locally         this.databaseVersion = databaseVersion;          // ship it to the database         PreparedStatement statement = null;         try {             statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;internal SET value = ? WHERE name = ?\&quot;);             statement.setInt(1, databaseVersion);             statement.setString(2, \&quot;version\&quot;);              // ok             statement.executeUpdate();         } catch (SQLException e) {          } finally {             safeClose(statement);         }     }      /**      * Get a value in the internal table      *      * @param key      * @return the value found, otherwise NULL if none exists      */     public String getInternal(String key) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT value FROM \&quot; + prefix + \&quot;internal WHERE name = ?\&quot;);             statement.setString(1, key);                          ResultSet set = statement.executeQuery();             if (set.next()) {                 String value = set.getString(\&quot;value\&quot;);                 set.close();                 return value;             }             set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Set a value in the internal table      *      * @param key      * @param value      */     public void setInternal(String key, String value) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;INSERT INTO \&quot; + prefix +\&quot;internal (name, value) VALUES (?, ?)\&quot;);             statement.setString(1, key);             statement.setString(2, value);              statement.executeUpdate();         } catch (SQLException e) {             safeClose(statement);             // Already exists             try {                 PreparedStatement statement2 = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;internal SET value = ? WHERE name = ?\&quot;);                 statement2.setString(1, value) ;                 statement2.setString(2, key);                  statement2.executeUpdate();             } catch (SQLException ex) {                 // Something bad went wrong                 printException(ex);             }         } finally {             safeClose(statement);         }     }      /**      * Load the database internal version      *      * @return      */     public int loadDatabaseVersion() {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT value FROM \&quot; + prefix + \&quot;internal WHERE name = ?\&quot;);             statement.setString(1, \&quot;version\&quot;);              // Execute it             ResultSet set = statement.executeQuery();              // load the version             if (set.next()) {                 databaseVersion = Integer.parseInt(set.getString(\&quot;value\&quot;));             } else {                 throw new IllegalStateException(\&quot;Internal is empty\&quot;);             }              // close everything             set.close();         } catch (Exception e) {             safeClose(statement);             // Doesn't exist, create it             try {                 PreparedStatement statement2 = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;internal (name, value) VALUES(?, ?)\&quot;);                 statement2.setString(1, \&quot;version\&quot;);                 statement2.setInt(2, databaseVersion);                  // ok                 statement2.executeUpdate();                 statement2.close();             } catch (SQLException ex) { }         } finally {             safeClose(statement);         }          return databaseVersion;     }      /**      * Load a protection with the given id      *      * @param id      * @return the Chest object      */     public Protection loadProtection(int id) {         // the protection cache         ProtectionCache cache = LWC.getInstance().getProtectionCache();          // check if the protection is already cached         Protection cached = cache.getProtectionById(id);         if (cached != null) {             return cached;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE id = ?\&quot;);             statement.setInt(1, id);              Protection protection = resolveProtection(statement);              if (protection != null) {                 cache.add(protection);                 return protection;             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load protections using a specific type      *      * @param type      * @return the Protection object      */     public List&lt;Protection&gt; loadProtectionsUsingType(Protection.Type type) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE type = ?\&quot;);             statement.setInt(1, type.ordinal());              return resolveProtections(statement);         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Resolve one protection from a ResultSet. The ResultSet is not closed.      *      * @param set      * @return      */     public Protection resolveProtection(ResultSet set) {         try {             Protection protection = new Protection();              int protectionId = set.getInt(\&quot;id\&quot;);             int x = set.getInt(\&quot;x\&quot;);             int y = set.getInt(\&quot;y\&quot;);             int z = set.getInt(\&quot;z\&quot;);             int blockId = set.getInt(\&quot;blockId\&quot;);             int type = set.getInt(\&quot;type\&quot;);             String world = set.getString(\&quot;world\&quot;);             String owner = set.getString(\&quot;owner\&quot;);             String password = set.getString(\&quot;password\&quot;);             String date = set.getString(\&quot;date\&quot;);             long lastAccessed = set.getLong(\&quot;last_accessed\&quot;);              protection.setId(protectionId);             protection.setX(x);             protection.setY(y);             protection.setZ(z);             protection.setBlockId(blockId);             protection.setType(Protection.Type.values()[type]);             protection.setWorld(world);             protection.setOwner(owner);             protection.setPassword(password);             protection.setCreation(date);             protection.setLastAccessed(lastAccessed);              // check for oh so beautiful data!             String data = set.getString(\&quot;data\&quot;);              if (data == null || data.trim().isEmpty()) {                 return protection;             }              // rev up them JSON parsers!             Object object = null;              try {                 object = jsonParser.parse(data);             } catch (Exception e) {                 return protection;             } catch (Error e) {                 return protection;             }              if (!(object instanceof JSONObject)) {                 return protection;             }              // obtain the root             JSONObject root = (JSONObject) object;             protection.getData().putAll(root);              // Attempt to parse rights             Object rights = root.get(\&quot;rights\&quot;);              if (rights != null &amp;&amp; (rights instanceof JSONArray)) {                 JSONArray array = (JSONArray) rights;                  for (Object node : array) {                     // we only want to use the maps                     if (!(node instanceof JSONObject)) {                         continue;                     }                      JSONObject map = (JSONObject) node;                      // decode the map                     Permission permission = Permission.decodeJSON(map);                      // bingo!                     if (permission != null) {                         protection.addPermission(permission);                     }                 }             }              // Attempt to parse flags             Object flags = root.get(\&quot;flags\&quot;);             if (flags != null &amp;&amp; (rights instanceof JSONArray)) {                 JSONArray array = (JSONArray) flags;                  for (Object node : array) {                     if (!(node instanceof JSONObject)) {                         continue;                     }                      JSONObject map = (JSONObject) node;                      Flag flag = Flag.decodeJSON(map);                      if (flag != null) {                         protection.addFlag(flag);                     }                 }             }              return protection;         } catch (SQLException e) {             printException(e);             return null;         }     }      /**      * Resolve every protection from a result set      *      * @param set      * @return      */     private List&lt;Protection&gt; resolveProtections(ResultSet set) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          try {             while (set.next()) {                 Protection protection = resolveProtection(set);                  if (protection != null) {                     protections.add(protection);                 }             }         } catch (SQLException e) {             printException(e);         }          return protections;     }      /**      * Resolve a list of protections from a statement      *      * @param statement      * @return      */     private List&lt;Protection&gt; resolveProtections(PreparedStatement statement) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();         ResultSet set = null;          try {             set = statement.executeQuery();             protections = resolveProtections(set);         } catch (SQLException e) {             printException(e);         } finally {             if (set != null) {                 try {                     set.close();                 } catch (SQLException e) {                 }             }         }          return protections;     }      /**      * Resolve the first protection from a statement      *      * @param statement      * @return      */     private Protection resolveProtection(PreparedStatement statement) {         List&lt;Protection&gt; protections = resolveProtections(statement);          if (protections.size() == 0) {             return null;         }          return protections.get(0);     }      /**      * Fill the protection cache as much as possible with protections      * Caches the most recent protections      */     public void precache() {         LWC lwc = LWC.getInstance();         ProtectionCache cache = lwc.getProtectionCache();          // clear the cache incase we're working on a dirty cache         cache.clear();          int precacheSize = lwc.getConfiguration().getInt(\&quot;core.precache\&quot;, -1);          if (precacheSize == -1) {             precacheSize = lwc.getConfiguration().getInt(\&quot;core.cacheSize\&quot;, 10000);         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections ORDER BY id DESC LIMIT ?\&quot;);             statement.setInt(1, precacheSize);             statement.setFetchSize(10);              // scrape the protections from the result set now             List&lt;Protection&gt; protections = resolveProtections(statement);              // throw all of the protections in             for (Protection protection : protections) {                 cache.add(protection);             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          // Cache them all     }      /**      * Load a protection at the given coordinates      *      * @param x      * @param y      * @param z      * @return the Protection object      */     public Protection loadProtection(String worldName, int x, int y, int z) {         return loadProtection(worldName, x, y, z, false);     }      /**      * Load a protection at the given coordinates      *      * @param x      * @param y      * @param z      * @param ignoreProtectionCount      * @return the Protection object      */     private Protection loadProtection(String worldName, int x, int y, int z, boolean ignoreProtectionCount) {         // the unique key to use in the cache         String cacheKey = worldName + \&quot;:\&quot; + x + \&quot;:\&quot; + y + \&quot;:\&quot; + z;          // the protection cache         ProtectionCache cache = LWC.getInstance().getProtectionCache();          // check if the protection is already cached         Protection cached = cache.getProtection(cacheKey);         if (cached != null) {             // System.out.println(\&quot;loadProtection() =&gt; CACHE HIT\&quot;);             return cached;         }          // Is it possible that there are protections in the cache?         if (!ignoreProtectionCount &amp;&amp; hasAllProtectionsCached()) {             // System.out.println(\&quot;loadProtection() =&gt; HAS_ALL_PROTECTIONS_CACHED\&quot;);             return null; // nothing was in the cache, nothing assumed to be in the database         }         // System.out.println(\&quot;loadProtection() =&gt; QUERYING\&quot;);          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE x = ? AND y = ? AND z = ? AND world = ?\&quot;);             statement.setInt(1, x);             statement.setInt(2, y);             statement.setInt(3, z);             statement.setString(4, worldName);              Protection protection = resolveProtection(statement);              if (protection != null) {                 // cache the protection                 cache.add(protection);             }              return protection;         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load all protections (use sparingly !!)      *      * @return      */     public List&lt;Protection&gt; loadProtections() {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections\&quot;);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Load the first protection within a block's radius      *      * @param world      * @param x      * @param y      * @param z      * @param radius      * @return list of Protection objects found      */     public List&lt;Protection&gt; loadProtections(String world, int x, int y, int z, int radius) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE world = ? AND x &gt;= ? AND x &lt;= ? AND y &gt;= ? AND y &lt;= ? AND z &gt;= ? AND z &lt;= ?\&quot;);              statement.setString(1, world);             statement.setInt(2, x - radius);             statement.setInt(3, x + radius);             statement.setInt(4, y - radius);             statement.setInt(5, y + radius);             statement.setInt(6, z - radius);             statement.setInt(7, z + radius);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Remove all protections for a given player      *      * @param player      * @return the amount of protections removed      */     public int removeProtectionsByPlayer(String player) {         int removed = 0;          for (Protection protection : loadProtectionsByPlayer(player)) {             protection.remove();             removed ++;         }          return removed;     }      /**      * Load all protections in the coordinate ranges      *      * @param world      * @param x1      * @param x2      * @param y1      * @param y2      * @param z1      * @param z2      * @return list of Protection objects found      */     public List&lt;Protection&gt; loadProtections(String world, int x1, int x2, int y1, int y2, int z1, int z2) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE world = ? AND x &gt;= ? AND x &lt;= ? AND y &gt;= ? AND y &lt;= ? AND z &gt;= ? AND z &lt;= ?\&quot;);              statement.setString(1, world);             statement.setInt(2, x1);             statement.setInt(3, x2);             statement.setInt(4, y1);             statement.setInt(5, y2);             statement.setInt(6, z1);             statement.setInt(7, z2);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Load protections by a player      *      * @param player      * @return      */     public List&lt;Protection&gt; loadProtectionsByPlayer(String player) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE owner = ?\&quot;);             statement.setString(1, player);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return protections;     }      /**      * Load protections by a player      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;Protection&gt; loadProtectionsByPlayer(String player, int start, int count) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE owner = ? ORDER BY id DESC limit ?,?\&quot;);             statement.setString(1, player);             statement.setInt(2, start);             statement.setInt(3, count);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return protections;     }      /**      * Register a protection      *      * @param blockId      * @param type      * @param world      * @param player      * @param data      * @param x      * @param y      * @param z      * @return      */     @Deprecated     public Protection registerProtection(int blockId, int type, String world, String player, String data, int x, int y, int z) {         return registerProtection(blockId, Protection.Type.values()[type], world, player, data, x, y, z);     }      /**      * Register a protection      *      * @param blockId      * @param type      * @param world      * @param player      * @param data      * @param x      * @param y      * @param z      * @return      */     public Protection registerProtection(int blockId, Protection.Type type, String world, String player, String data, int x, int y, int z) {         ProtectionCache cache = LWC.getInstance().getProtectionCache();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;protections (blockId, type, world, owner, password, x, y, z, date, last_accessed) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;);              statement.setInt(1, blockId);             statement.setInt(2, type.ordinal());             statement.setString(3, world);             statement.setString(4, player);             statement.setString(5, data);             statement.setInt(6, x);             statement.setInt(7, y);             statement.setInt(8, z);             statement.setString(9, new Timestamp(new Date().getTime()).toString());             statement.setLong(10, System.currentTimeMillis() / 1000L);              statement.executeUpdate();              // We need to create the initial transaction for this protection             // this transaction is viewable and modifiable during POST_REGISTRATION             Protection protection = loadProtection(world, x, y, z, true);              // if history logging is enabled, create it             if (LWC.getInstance().isHistoryEnabled() &amp;&amp; protection != null) {                 History transaction = protection.createHistoryObject();                  transaction.setPlayer(player);                 transaction.setType(History.Type.TRANSACTION);                 transaction.setStatus(History.Status.ACTIVE);                  // store the player that created the protection                 transaction.addMetaData(\&quot;creator=\&quot; + player);                  // now sync the history object to the database                 transaction.saveNow();             }                          // Cache it             if (protection != null) {                 cache.add(protection);                 protectionCount ++;             }              // return the newly created protection             return protection;         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Sync a History object to the database or save a newly created one      *      * @param history      */     public void saveHistory(History history) {         PreparedStatement statement = null;         try {             if (history.doesExist()) {                 statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;history SET protectionId = ?, player = ?, x = ?, y = ?, z = ?, type = ?, status = ?, metadata = ?, timestamp = ? WHERE id = ?\&quot;);             } else {                 statement = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;history (protectionId, player, x, y, z, type, status, metadata, timestamp) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;, true);                 history.setTimestamp(System.currentTimeMillis() / 1000L);             }              statement.setInt(1, history.getProtectionId());             statement.setString(2, history.getPlayer());             statement.setInt(3, history.getX());             statement.setInt(4, history.getY());             statement.setInt(5, history.getZ());             statement.setInt(6, history.getType().ordinal());             statement.setInt(7, history.getStatus().ordinal());             statement.setString(8, history.getSafeMetaData());             statement.setLong(9, history.getTimestamp());              if (history.doesExist()) {                 statement.setInt(10, history.getId());             }              int affectedRows;              if (statement instanceof AutoClosingPreparedStatement) {                 affectedRows = ((AutoClosingPreparedStatement) statement).executeUpdate(false);             } else {                 affectedRows = statement.executeUpdate();             }              // set the history id if inserting             if (!history.doesExist()) {                 if (affectedRows &gt; 0) {                     ResultSet generatedKeys = statement.getGeneratedKeys();                      // get the key inserted                     if (generatedKeys.next()) {                         history.setId(generatedKeys.getInt(1));                     }                      generatedKeys.close();                 }             }              statement.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Invalid all history objects for a player      *       * @param player      */     public void invalidateHistory(String player) {        try {            PreparedStatement statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;history SET status = ? WHERE Lower(player) = Lower(?)\&quot;);            statement.setInt(1, History.Status.INACTIVE.ordinal());            statement.setString(2, player);             statement.executeUpdate();        } catch (SQLException e) {            printException(e);        }     }      /**      * Resolve 1 history object from the result set but do not close it      *      * @return      */     private History resolveHistory(History history, ResultSet set) throws SQLException {         if (history == null) {             return null;         }          int historyId = set.getInt(\&quot;id\&quot;);         int protectionId = set.getInt(\&quot;protectionId\&quot;);         int x = set.getInt(\&quot;x\&quot;);         int y = set.getInt(\&quot;y\&quot;);         int z = set.getInt(\&quot;z\&quot;);         String player = set.getString(\&quot;player\&quot;);         int type_ord = set.getInt(\&quot;type\&quot;);         int status_ord = set.getInt(\&quot;status\&quot;);         String[] metadata = set.getString(\&quot;metadata\&quot;).split(\&quot;,\&quot;);         long timestamp = set.getLong(\&quot;timestamp\&quot;);          History.Type type = History.Type.values()[type_ord];         History.Status status = History.Status.values()[status_ord];          history.setId(historyId);         history.setProtectionId(protectionId);         history.setType(type);         history.setPlayer(player);         history.setX(x);         history.setY(y);         history.setZ(z);         history.setStatus(status);         history.setMetaData(metadata);         history.setTimestamp(timestamp);          return history;     }      /**      * Load all of the History objects for a given protection      *      * @param protection      * @return      */     public List&lt;History&gt; loadHistory(Protection protection) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE protectionId = ? ORDER BY id DESC\&quot;);             statement.setInt(1, protection.getId());              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(protection.createHistoryObject(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history that the given player created      *      * @param player      * @return      */     public List&lt;History&gt; loadHistory(Player player) {         return loadHistory(player.getName());     }      /**      * Load all protection history that the given player created      *      * @param player      * @return      */     public List&lt;History&gt; loadHistory(String player) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) ORDER BY id DESC\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history that has the given history id      *      * @param historyId      * @return      */     public History loadHistory(int historyId) {         if (!LWC.getInstance().isHistoryEnabled()) {             return null;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE id = ?\&quot;);             statement.setInt(1, historyId);              ResultSet set = statement.executeQuery();              if (set.next()) {                 History history = resolveHistory(new History(), set);                  set.close();                 return history;             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load all protection history that the given player created for a given page, getting count history items.      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;History&gt; loadHistory(Player player, int start, int count) {         return loadHistory(player.getName(), start, count);     }      /**      * Load all protection history that the given player created for a given page, getting count history items.      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;History&gt; loadHistory(String player, int start, int count) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) ORDER BY id DESC LIMIT ?,?\&quot;);             statement.setString(1, player);             statement.setInt(2, start);             statement.setInt(3, count);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history      *      * @return      */     public List&lt;History&gt; loadHistory() {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {              statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history ORDER BY   \&quot;              \t+ id + \&quot;DESC\&quot;);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history for the given status      *      * @return      */     public List&lt;History&gt; loadHistory(History.Status status) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE status = ? ORDER BY id DESC\&quot;);             statement.setInt(1, status.ordinal());             ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all of the history at the given location      *      * @param x      * @param y      * @param z      * @return      */     public List&lt;History&gt; loadHistory(int x, int y, int z) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE x = ? AND y = ? AND z = ?\&quot;);             statement.setInt(1, x);             statement.setInt(2, y);             statement.setInt(3, z);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all of the history at the given location      *      * @param player      * @param x      * @param y      * @param z      * @return      */     public List&lt;History&gt; loadHistory(String player, int x, int y, int z) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) AND x = ? AND y = ? AND z = ?\&quot;);             statement.setString(1, player);             statement.setInt(2, x);             statement.setInt(3, y);             statement.setInt(4, z);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history      *      * @return      */     public List&lt;History&gt; loadHistory(int start, int count) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history ORDER BY id DESC LIMIT ?,?\&quot;);             statement.setInt(1, start);             statement.setInt(2, count);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Save a protection to the database      *      * @param protection      */     public void saveProtection(Protection protection) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;REPLACE INTO \&quot;              \t+ prefix + \&quot;protections (id, type, blockId, world, data, owner, password, x, y, z, date, last_accessed) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;);              statement.setInt(1, protection.getId());             statement.setInt(2, protection.getType().ordinal());             statement.setInt(3, protection.getBlockId());             statement.setString(4, protection.getWorld());             statement.setString(5, protection.getData().toJSONString());             statement.setString(6, protection.getOwner());             statement.setString(7, protection.getPassword());             statement.setInt(8, protection.getX());             statement.setInt(9, protection.getY());             statement.setInt(10, protection.getZ());             statement.setString(11, protection.getCreation());             statement.setLong(12, protection.getLastAccessed());              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Free a chest from protection      *      * @param protectionId the protection Id      */     public void removeProtection(int protectionId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;protections WHERE id = ?\&quot;);             statement.setInt(1, protectionId);              int affected = statement.executeUpdate();              if (affected &gt;= 1) {                 protectionCount -= affected;             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          // removeProtectionHistory(protectionId);     }      public void removeProtectionHistory(int protectionId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;history WHERE protectionId = ?\&quot;);             statement.setInt(1, protectionId);              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      public void removeHistory(int historyId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;history WHERE id = ?\&quot;);             statement.setInt(1, historyId);              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Remove **&lt;b&gt;ALL&lt;/b&gt;** all of the protections registered by LWC      */     public void removeAllProtections() {         try {             Connection connection = createConnection();             Statement statement = connection.createStatement();             statement.executeUpdate(\&quot;DELETE FROM \&quot; + prefix + \&quot;protections\&quot;);             protectionCount = 0;             statement.close();             connection.close();         } catch (SQLException e) {             printException(e);         }     }      /**      * Attempt to create an index on the table      *      * @param table      * @param indexName      * @param columns      */     private void createIndex(String table, String indexName, String columns) {         Connection connection = null;         Statement statement = null;          try {             connection = createConnection();             statement = connection.createStatement();             statement.executeUpdate(\&quot;CREATE INDEX\&quot; + (currentType == Type.SQLite ? \&quot; IF NOT EXISTS\&quot; : \&quot;\&quot;) + \&quot; \&quot; + indexName + \&quot; ON \&quot; + prefix + table + \&quot; (\&quot; + columns + \&quot;)\&quot;);         } catch (Exception e) {         } finally {             if (statement != null) {                 try {                     statement.close();                 } catch (SQLException e) {                 }             }             if (connection != null) {                 try {                     connection.close();                 } catch (SQLException e) {                 }             }         }     }      /**      * Attempt to create an index on the table      *      * @param indexName      */     private void dropIndex(String table, String indexName) {         Connection connection = null;         Statement statement = null;          try {             connection = createConnection();             statement = connection.createStatement();              if (currentType == Type.SQLite) {                 statement.executeUpdate(\&quot;DROP INDEX IF EXISTS \&quot; + indexName);             } else {                 statement.executeUpdate(\&quot;DROP INDEX \&quot; + indexName + \&quot; ON \&quot; + prefix + table);             }         } catch (Exception e) {         } finally {             if (statement != null) {                 try {                     statement.close();                 } catch (SQLException e) {                 }             }             if (connection != null) {                 try {                     connection.close();                 } catch (SQLException e) {                 }             }         }     }  } &quot;</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>&quot;/*  * Copyright 2011 Tyler Blair. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *    1. Redistributions of source code must retain the above copyright notice, this list of  *       conditions and the following disclaimer.  *  *    2. Redistributions in binary form must reproduce the above copyright notice, this list  *       of conditions and the following disclaimer in the documentation and/or other materials  *       provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are those of the  * authors and contributors and should not be interpreted as representing official policies,  * either expressed or implied, of anybody else.  */  package com.griefcraft.sql;  import com.griefcraft.cache.ProtectionCache; import com.griefcraft.lwc.LWC; import com.griefcraft.model.Flag; import com.griefcraft.model.History; import com.griefcraft.model.Permission; import com.griefcraft.model.Protection; import org.bukkit.entity.Player; import org.json.simple.JSONArray; import org.json.simple.JSONObject; import org.json.simple.parser.JSONParser;  import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.sql.Timestamp; import java.util.ArrayList; import java.util.Date; import java.util.List;  public class PhysDB extends Database {      /**      * The JSON Parser object      */     private final JSONParser jsonParser = new JSONParser();      /**      * The database version      */     private int databaseVersion = 0;      /**      * The number of protections that should exist      */     private int protectionCount = 0;      public PhysDB() {         super();     }      public PhysDB(Type currentType) {         super(currentType);     }      /**      * Decrement the known protection counter      */     public void decrementProtectionCount() {         protectionCount --;     }      /**      * Check if the protection cache has all of the known protections cached      *      * @return      */     public boolean hasAllProtectionsCached() {         ProtectionCache cache = LWC.getInstance().getProtectionCache();          return cache.size() &gt;= protectionCount;     }      /**      * Fetch an object from the sql database      *      * @param sql      * @param column      * @return      */     private Object fetch(String sql, String column, Object... toBind) {         PreparedStatement statement = null;         try {             int index = 1;             statement = prepare(sql);              for (Object bind : toBind) {                 statement.setObject(index, bind);                 index++;             }              ResultSet set = statement.executeQuery();              if (set.next()) {                 Object object = set.getObject(column);                 set.close();                 return object;             }              set.close();         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Get the total amount of protections      * @return the number of protections      */     public int getProtectionCount() {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections\&quot;, \&quot;count\&quot;).toString());     }      /**      * Get the amount of protections for the given protection type      * @param type      * @return the number of protected chests      */     public int getProtectionCount(Protection.Type type) {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections WHERE type = \&quot; + type.ordinal(), \&quot;count\&quot;).toString());     }      /**      * @return the number of history items stored      */     public int getHistoryCount() {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;history\&quot;, \&quot;count\&quot;).toString());     }      /**      * Get the amount of protections a player has      *      * @param player      * @return the amount of protections they have      */     public int getProtectionCount(String player) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) as count FROM \&quot; + prefix + \&quot;protections WHERE owner = ?\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the amount of protections a player has      *      * @param player      * @return the amount of protections they have      */     public int getHistoryCount(String player) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?)\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the amount of chests a player has of a specific block id      *      * @param player      * @return the amount of protections they have of blockId      */     public int getProtectionCount(String player, int blockId) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections WHERE owner = ? AND blockId = ?\&quot;);             statement.setString(1, player);             statement.setInt(2, blockId);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the menu style for a player      *      * @param player      * @return      * @deprecated      */     public String getMenuStyle(String player) {         return \&quot;basic\&quot;;     }      /**      * Load the database and do any updating required or create the tables      */     @Override     public void load() {         if (loaded) {             return;         }          Column column;          Table protections = new Table(this, \&quot;protections\&quot;);         {             column = new Column(\&quot;id\&quot;);             column.setType(\&quot;INTEGER\&quot;);             column.setPrimary(true);             protections.add(column);              column = new Column(\&quot;owner\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;type\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;x\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;y\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;z\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;flags\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;data\&quot;);             column.setType(\&quot;TEXT\&quot;);             protections.add(column);              column = new Column(\&quot;blockId\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;world\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;password\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;date\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;last_accessed\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);         }          Table history = new Table(this, \&quot;history\&quot;);         {             column = new Column(\&quot;id\&quot;);             column.setType(\&quot;INTEGER\&quot;);             column.setPrimary(true);             history.add(column);              column = new Column(\&quot;protectionId\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;player\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             history.add(column);              column = new Column(\&quot;x\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;y\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;z\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;type\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;status\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;metadata\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             history.add(column);              column = new Column(\&quot;timestamp\&quot;);             column.setType(\&quot;long\&quot;);             history.add(column);         }          Table internal = new Table(this, \&quot;internal\&quot;);         {             column = new Column(\&quot;name\&quot;);             column.setType(\&quot;VARCHAR(40)\&quot;);             column.setPrimary(true);             column.setAutoIncrement(false);             internal.add(column);              column = new Column(\&quot;value\&quot;);             column.setType(\&quot;VARCHAR(40)\&quot;);             internal.add(column);         }          protections.execute();         history.execute();         internal.execute();          // Load the database version         loadDatabaseVersion();          // perform database upgrades         performDatabaseUpdates();          // get the amount of protections         protectionCount = getProtectionCount();          loaded = true;     }      /**      * Perform any database updates      */     public void performDatabaseUpdates() {          // Indexes         if (databaseVersion == 0) {             // Drop old, old indexes             log(\&quot;Dropping old indexes (One time, may take a while!)\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in1\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in6\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in7\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in8\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in9\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in10\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in12\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in13\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in14\&quot;);              // Create our updated (good) indexes             log(\&quot;Creating new indexes (One time, may take a while!)\&quot;);             createIndex(\&quot;protections\&quot;, \&quot;protections_main\&quot;, \&quot;x, y, z, world\&quot;);             createIndex(\&quot;protections\&quot;, \&quot;protections_utility\&quot;, \&quot;owner\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_main\&quot;, \&quot;protectionId\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_utility\&quot;, \&quot;player\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_utility2\&quot;, \&quot;x, y, z\&quot;);              // increment the database version             incrementDatabaseVersion();         }          if (databaseVersion == 1) {             log(\&quot;Creating index on internal\&quot;);             createIndex(\&quot;internal\&quot;, \&quot;internal_main\&quot;, \&quot;name\&quot;);             incrementDatabaseVersion();         }          if (databaseVersion == 2) {             incrementDatabaseVersion();         }                  if (databaseVersion == 3) {             createIndex(\&quot;protections\&quot;, \&quot;protections_type\&quot;, \&quot;type\&quot;);             incrementDatabaseVersion();         }      }      /**      * Increment the database version      */     public void incrementDatabaseVersion() {         setDatabaseVersion(++databaseVersion);     }      /**      * Set the database version and sync it to the database      *       * @param databaseVersion      */     public void setDatabaseVersion(int databaseVersion) {         // set it locally         this.databaseVersion = databaseVersion;          // ship it to the database         PreparedStatement statement = null;         try {             statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;internal SET value = ? WHERE name = ?\&quot;);             statement.setInt(1, databaseVersion);             statement.setString(2, \&quot;version\&quot;);              // ok             statement.executeUpdate();         } catch (SQLException e) {          } finally {             safeClose(statement);         }     }      /**      * Get a value in the internal table      *      * @param key      * @return the value found, otherwise NULL if none exists      */     public String getInternal(String key) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT value FROM \&quot; + prefix + \&quot;internal WHERE name = ?\&quot;);             statement.setString(1, key);                          ResultSet set = statement.executeQuery();             if (set.next()) {                 String value = set.getString(\&quot;value\&quot;);                 set.close();                 return value;             }             set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Set a value in the internal table      *      * @param key      * @param value      */     public void setInternal(String key, String value) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;INSERT INTO \&quot; + prefix +\&quot;internal (name, value) VALUES (?, ?)\&quot;);             statement.setString(1, key);             statement.setString(2, value);              statement.executeUpdate();         } catch (SQLException e) {             safeClose(statement);             // Already exists             try {                 PreparedStatement statement2 = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;internal SET value = ? WHERE name = ?\&quot;);                 statement2.setString(1, value) ;                 statement2.setString(2, key);                  statement2.executeUpdate();             } catch (SQLException ex) {                 // Something bad went wrong                 printException(ex);             }         } finally {             safeClose(statement);         }     }      /**      * Load the database internal version      *      * @return      */     public int loadDatabaseVersion() {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT value FROM \&quot; + prefix + \&quot;internal WHERE name = ?\&quot;);             statement.setString(1, \&quot;version\&quot;);              // Execute it             ResultSet set = statement.executeQuery();              // load the version             if (set.next()) {                 databaseVersion = Integer.parseInt(set.getString(\&quot;value\&quot;));             } else {                 throw new IllegalStateException(\&quot;Internal is empty\&quot;);             }              // close everything             set.close();         } catch (Exception e) {             safeClose(statement);             // Doesn't exist, create it             try {                 PreparedStatement statement2 = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;internal (name, value) VALUES(?, ?)\&quot;);                 statement2.setString(1, \&quot;version\&quot;);                 statement2.setInt(2, databaseVersion);                  // ok                 statement2.executeUpdate();                 statement2.close();             } catch (SQLException ex) { }         } finally {             safeClose(statement);         }          return databaseVersion;     }      /**      * Load a protection with the given id      *      * @param id      * @return the Chest object      */     public Protection loadProtection(int id) {         // the protection cache         ProtectionCache cache = LWC.getInstance().getProtectionCache();          // check if the protection is already cached         Protection cached = cache.getProtectionById(id);         if (cached != null) {             return cached;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE id = ?\&quot;);             statement.setInt(1, id);              Protection protection = resolveProtection(statement);              if (protection != null) {                 cache.add(protection);                 return protection;             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load protections using a specific type      *      * @param type      * @return the Protection object      */     public List&lt;Protection&gt; loadProtectionsUsingType(Protection.Type type) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE type = ?\&quot;);             statement.setInt(1, type.ordinal());              return resolveProtections(statement);         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Resolve one protection from a ResultSet. The ResultSet is not closed.      *      * @param set      * @return      */     public Protection resolveProtection(ResultSet set) {         try {             Protection protection = new Protection();              int protectionId = set.getInt(\&quot;id\&quot;);             int x = set.getInt(\&quot;x\&quot;);             int y = set.getInt(\&quot;y\&quot;);             int z = set.getInt(\&quot;z\&quot;);             int blockId = set.getInt(\&quot;blockId\&quot;);             int type = set.getInt(\&quot;type\&quot;);             String world = set.getString(\&quot;world\&quot;);             String owner = set.getString(\&quot;owner\&quot;);             String password = set.getString(\&quot;password\&quot;);             String date = set.getString(\&quot;date\&quot;);             long lastAccessed = set.getLong(\&quot;last_accessed\&quot;);              protection.setId(protectionId);             protection.setX(x);             protection.setY(y);             protection.setZ(z);             protection.setBlockId(blockId);             protection.setType(Protection.Type.values()[type]);             protection.setWorld(world);             protection.setOwner(owner);             protection.setPassword(password);             protection.setCreation(date);             protection.setLastAccessed(lastAccessed);              // check for oh so beautiful data!             String data = set.getString(\&quot;data\&quot;);              if (data == null || data.trim().isEmpty()) {                 return protection;             }              // rev up them JSON parsers!             Object object = null;              try {                 object = jsonParser.parse(data);             } catch (Exception e) {                 return protection;             } catch (Error e) {                 return protection;             }              if (!(object instanceof JSONObject)) {                 return protection;             }              // obtain the root             JSONObject root = (JSONObject) object;             protection.getData().putAll(root);              // Attempt to parse rights             Object rights = root.get(\&quot;rights\&quot;);              if (rights != null &amp;&amp; (rights instanceof JSONArray)) {                 JSONArray array = (JSONArray) rights;                  for (Object node : array) {                     // we only want to use the maps                     if (!(node instanceof JSONObject)) {                         continue;                     }                      JSONObject map = (JSONObject) node;                      // decode the map                     Permission permission = Permission.decodeJSON(map);                      // bingo!                     if (permission != null) {                         protection.addPermission(permission);                     }                 }             }              // Attempt to parse flags             Object flags = root.get(\&quot;flags\&quot;);             if (flags != null &amp;&amp; (rights instanceof JSONArray)) {                 JSONArray array = (JSONArray) flags;                  for (Object node : array) {                     if (!(node instanceof JSONObject)) {                         continue;                     }                      JSONObject map = (JSONObject) node;                      Flag flag = Flag.decodeJSON(map);                      if (flag != null) {                         protection.addFlag(flag);                     }                 }             }              return protection;         } catch (SQLException e) {             printException(e);             return null;         }     }      /**      * Resolve every protection from a result set      *      * @param set      * @return      */     private List&lt;Protection&gt; resolveProtections(ResultSet set) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          try {             while (set.next()) {                 Protection protection = resolveProtection(set);                  if (protection != null) {                     protections.add(protection);                 }             }         } catch (SQLException e) {             printException(e);         }          return protections;     }      /**      * Resolve a list of protections from a statement      *      * @param statement      * @return      */     private List&lt;Protection&gt; resolveProtections(PreparedStatement statement) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();         ResultSet set = null;          try {             set = statement.executeQuery();             protections = resolveProtections(set);         } catch (SQLException e) {             printException(e);         } finally {             if (set != null) {                 try {                     set.close();                 } catch (SQLException e) {                 }             }         }          return protections;     }      /**      * Resolve the first protection from a statement      *      * @param statement      * @return      */     private Protection resolveProtection(PreparedStatement statement) {         List&lt;Protection&gt; protections = resolveProtections(statement);          if (protections.size() == 0) {             return null;         }          return protections.get(0);     }      /**      * Fill the protection cache as much as possible with protections      * Caches the most recent protections      */     public void precache() {         LWC lwc = LWC.getInstance();         ProtectionCache cache = lwc.getProtectionCache();          // clear the cache incase we're working on a dirty cache         cache.clear();          int precacheSize = lwc.getConfiguration().getInt(\&quot;core.precache\&quot;, -1);          if (precacheSize == -1) {             precacheSize = lwc.getConfiguration().getInt(\&quot;core.cacheSize\&quot;, 10000);         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections ORDER BY id DESC LIMIT ?\&quot;);             statement.setInt(1, precacheSize);             statement.setFetchSize(10);              // scrape the protections from the result set now             List&lt;Protection&gt; protections = resolveProtections(statement);              // throw all of the protections in             for (Protection protection : protections) {                 cache.add(protection);             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          // Cache them all     }      /**      * Load a protection at the given coordinates      *      * @param x      * @param y      * @param z      * @return the Protection object      */     public Protection loadProtection(String worldName, int x, int y, int z) {         return loadProtection(worldName, x, y, z, false);     }      /**      * Load a protection at the given coordinates      *      * @param x      * @param y      * @param z      * @param ignoreProtectionCount      * @return the Protection object      */     private Protection loadProtection(String worldName, int x, int y, int z, boolean ignoreProtectionCount) {         // the unique key to use in the cache         String cacheKey = worldName + \&quot;:\&quot; + x + \&quot;:\&quot; + y + \&quot;:\&quot; + z;          // the protection cache         ProtectionCache cache = LWC.getInstance().getProtectionCache();          // check if the protection is already cached         Protection cached = cache.getProtection(cacheKey);         if (cached != null) {             // System.out.println(\&quot;loadProtection() =&gt; CACHE HIT\&quot;);             return cached;         }          // Is it possible that there are protections in the cache?         if (!ignoreProtectionCount &amp;&amp; hasAllProtectionsCached()) {             // System.out.println(\&quot;loadProtection() =&gt; HAS_ALL_PROTECTIONS_CACHED\&quot;);             return null; // nothing was in the cache, nothing assumed to be in the database         }         // System.out.println(\&quot;loadProtection() =&gt; QUERYING\&quot;);          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE x = ? AND y = ? AND z = ? AND world = ?\&quot;);             statement.setInt(1, x);             statement.setInt(2, y);             statement.setInt(3, z);             statement.setString(4, worldName);              Protection protection = resolveProtection(statement);              if (protection != null) {                 // cache the protection                 cache.add(protection);             }              return protection;         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load all protections (use sparingly !!)      *      * @return      */     public List&lt;Protection&gt; loadProtections() {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections\&quot;);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Load the first protection within a block's radius      *      * @param world      * @param x      * @param y      * @param z      * @param radius      * @return list of Protection objects found      */     public List&lt;Protection&gt; loadProtections(String world, int x, int y, int z, int radius) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE world = ? AND x &gt;= ? AND x &lt;= ? AND y &gt;= ? AND y &lt;= ? AND z &gt;= ? AND z &lt;= ?\&quot;);              statement.setString(1, world);             statement.setInt(2, x - radius);             statement.setInt(3, x + radius);             statement.setInt(4, y - radius);             statement.setInt(5, y + radius);             statement.setInt(6, z - radius);             statement.setInt(7, z + radius);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Remove all protections for a given player      *      * @param player      * @return the amount of protections removed      */     public int removeProtectionsByPlayer(String player) {         int removed = 0;          for (Protection protection : loadProtectionsByPlayer(player)) {             protection.remove();             removed ++;         }          return removed;     }      /**      * Load all protections in the coordinate ranges      *      * @param world      * @param x1      * @param x2      * @param y1      * @param y2      * @param z1      * @param z2      * @return list of Protection objects found      */     public List&lt;Protection&gt; loadProtections(String world, int x1, int x2, int y1, int y2, int z1, int z2) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE world = ? AND x &gt;= ? AND x &lt;= ? AND y &gt;= ? AND y &lt;= ? AND z &gt;= ? AND z &lt;= ?\&quot;);              statement.setString(1, world);             statement.setInt(2, x1);             statement.setInt(3, x2);             statement.setInt(4, y1);             statement.setInt(5, y2);             statement.setInt(6, z1);             statement.setInt(7, z2);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Load protections by a player      *      * @param player      * @return      */     public List&lt;Protection&gt; loadProtectionsByPlayer(String player) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE owner = ?\&quot;);             statement.setString(1, player);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return protections;     }      /**      * Load protections by a player      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;Protection&gt; loadProtectionsByPlayer(String player, int start, int count) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE owner = ? ORDER BY id DESC limit ?,?\&quot;);             statement.setString(1, player);             statement.setInt(2, start);             statement.setInt(3, count);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return protections;     }      /**      * Register a protection      *      * @param blockId      * @param type      * @param world      * @param player      * @param data      * @param x      * @param y      * @param z      * @return      */     @Deprecated     public Protection registerProtection(int blockId, int type, String world, String player, String data, int x, int y, int z) {         return registerProtection(blockId, Protection.Type.values()[type], world, player, data, x, y, z);     }      /**      * Register a protection      *      * @param blockId      * @param type      * @param world      * @param player      * @param data      * @param x      * @param y      * @param z      * @return      */     public Protection registerProtection(int blockId, Protection.Type type, String world, String player, String data, int x, int y, int z) {         ProtectionCache cache = LWC.getInstance().getProtectionCache();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;protections (blockId, type, world, owner, password, x, y, z, date, last_accessed) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;);              statement.setInt(1, blockId);             statement.setInt(2, type.ordinal());             statement.setString(3, world);             statement.setString(4, player);             statement.setString(5, data);             statement.setInt(6, x);             statement.setInt(7, y);             statement.setInt(8, z);             statement.setString(9, new Timestamp(new Date().getTime()).toString());             statement.setLong(10, System.currentTimeMillis() / 1000L);              statement.executeUpdate();              // We need to create the initial transaction for this protection             // this transaction is viewable and modifiable during POST_REGISTRATION             Protection protection = loadProtection(world, x, y, z, true);              // if history logging is enabled, create it             if (LWC.getInstance().isHistoryEnabled() &amp;&amp; protection != null) {                 History transaction = protection.createHistoryObject();                  transaction.setPlayer(player);                 transaction.setType(History.Type.TRANSACTION);                 transaction.setStatus(History.Status.ACTIVE);                  // store the player that created the protection                 transaction.addMetaData(\&quot;creator=\&quot; + player);                  // now sync the history object to the database                 transaction.saveNow();             }                          // Cache it             if (protection != null) {                 cache.add(protection);                 protectionCount ++;             }              // return the newly created protection             return protection;         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Sync a History object to the database or save a newly created one      *      * @param history      */     public void saveHistory(History history) {         PreparedStatement statement = null;         try {             if (history.doesExist()) {                 statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;history SET protectionId = ?, player = ?, x = ?, y = ?, z = ?, type = ?, status = ?, metadata = ?, timestamp = ? WHERE id = ?\&quot;);             } else {                 statement = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;history (protectionId, player, x, y, z, type, status, metadata, timestamp) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;, true);                 history.setTimestamp(System.currentTimeMillis() / 1000L);             }              statement.setInt(1, history.getProtectionId());             statement.setString(2, history.getPlayer());             statement.setInt(3, history.getX());             statement.setInt(4, history.getY());             statement.setInt(5, history.getZ());             statement.setInt(6, history.getType().ordinal());             statement.setInt(7, history.getStatus().ordinal());             statement.setString(8, history.getSafeMetaData());             statement.setLong(9, history.getTimestamp());              if (history.doesExist()) {                 statement.setInt(10, history.getId());             }              int affectedRows;              if (statement instanceof AutoClosingPreparedStatement) {                 affectedRows = ((AutoClosingPreparedStatement) statement).executeUpdate(false);             } else {                 affectedRows = statement.executeUpdate();             }              // set the history id if inserting             if (!history.doesExist()) {                 if (affectedRows &gt; 0) {                     ResultSet generatedKeys = statement.getGeneratedKeys();                      // get the key inserted                     if (generatedKeys.next()) {                         history.setId(generatedKeys.getInt(1));                     }                      generatedKeys.close();                 }             }              statement.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Invalid all history objects for a player      *       * @param player      */     public void invalidateHistory(String player) {        try {            PreparedStatement statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;history SET status = ? WHERE Lower(player) = Lower(?)\&quot;);            statement.setInt(1, History.Status.INACTIVE.ordinal());            statement.setString(2, player);             statement.executeUpdate();        } catch (SQLException e) {            printException(e);        }     }      /**      * Resolve 1 history object from the result set but do not close it      *      * @return      */     private History resolveHistory(History history, ResultSet set) throws SQLException {         if (history == null) {             return null;         }          int historyId = set.getInt(\&quot;id\&quot;);         int protectionId = set.getInt(\&quot;protectionId\&quot;);         int x = set.getInt(\&quot;x\&quot;);         int y = set.getInt(\&quot;y\&quot;);         int z = set.getInt(\&quot;z\&quot;);         String player = set.getString(\&quot;player\&quot;);         int type_ord = set.getInt(\&quot;type\&quot;);         int status_ord = set.getInt(\&quot;status\&quot;);         String[] metadata = set.getString(\&quot;metadata\&quot;).split(\&quot;,\&quot;);         long timestamp = set.getLong(\&quot;timestamp\&quot;);          History.Type type = History.Type.values()[type_ord];         History.Status status = History.Status.values()[status_ord];          history.setId(historyId);         history.setProtectionId(protectionId);         history.setType(type);         history.setPlayer(player);         history.setX(x);         history.setY(y);         history.setZ(z);         history.setStatus(status);         history.setMetaData(metadata);         history.setTimestamp(timestamp);          return history;     }      /**      * Load all of the History objects for a given protection      *      * @param protection      * @return      */     public List&lt;History&gt; loadHistory(Protection protection) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE protectionId = ? ORDER BY id DESC\&quot;);             statement.setInt(1, protection.getId());              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(protection.createHistoryObject(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history that the given player created      *      * @param player      * @return      */     public List&lt;History&gt; loadHistory(Player player) {         return loadHistory(player.getName());     }      /**      * Load all protection history that the given player created      *      * @param player      * @return      */     public List&lt;History&gt; loadHistory(String player) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) ORDER BY id DESC\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history that has the given history id      *      * @param historyId      * @return      */     public History loadHistory(int historyId) {         if (!LWC.getInstance().isHistoryEnabled()) {             return null;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE id = ?\&quot;);             statement.setInt(1, historyId);              ResultSet set = statement.executeQuery();              if (set.next()) {                 History history = resolveHistory(new History(), set);                  set.close();                 return history;             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load all protection history that the given player created for a given page, getting count history items.      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;History&gt; loadHistory(Player player, int start, int count) {         return loadHistory(player.getName(), start, count);     }      /**      * Load all protection history that the given player created for a given page, getting count history items.      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;History&gt; loadHistory(String player, int start, int count) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) ORDER BY id DESC LIMIT ?,?\&quot;);             statement.setString(1, player);             statement.setInt(2, start);             statement.setInt(3, count);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history      *      * @return      */     public List&lt;History&gt; loadHistory() {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history ORDER BY\&quot; + id + \&quot;DESC\&quot;);                      ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history for the given status      *      * @return      */     public List&lt;History&gt; loadHistory(History.Status status) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE status = ? ORDER BY id DESC\&quot;);             statement.setInt(1, status.ordinal());             ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all of the history at the given location      *      * @param x      * @param y      * @param z      * @return      */     public List&lt;History&gt; loadHistory(int x, int y, int z) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE x = ? AND y = ? AND z = ?\&quot;);             statement.setInt(1, x);             statement.setInt(2, y);             statement.setInt(3, z);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all of the history at the given location      *      * @param player      * @param x      * @param y      * @param z      * @return      */     public List&lt;History&gt; loadHistory(String player, int x, int y, int z) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) AND x = ? AND y = ? AND z = ?\&quot;);             statement.setString(1, player);             statement.setInt(2, x);             statement.setInt(3, y);             statement.setInt(4, z);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history      *      * @return      */     public List&lt;History&gt; loadHistory(int start, int count) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history ORDER BY id DESC LIMIT ?,?\&quot;);             statement.setInt(1, start);             statement.setInt(2, count);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Save a protection to the database      *      * @param protection      */     public void saveProtection(Protection protection) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;REPLACE INTO \&quot;              \t+ prefix + \&quot;protections (id, type, blockId, world, data, owner, password, x, y, z, date, last_accessed) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;);              statement.setInt(1, protection.getId());             statement.setInt(2, protection.getType().ordinal());             statement.setInt(3, protection.getBlockId());             statement.setString(4, protection.getWorld());             statement.setString(5, protection.getData().toJSONString());             statement.setString(6, protection.getOwner());             statement.setString(7, protection.getPassword());             statement.setInt(8, protection.getX());             statement.setInt(9, protection.getY());             statement.setInt(10, protection.getZ());             statement.setString(11, protection.getCreation());             statement.setLong(12, protection.getLastAccessed());              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Free a chest from protection      *      * @param protectionId the protection Id      */     public void removeProtection(int protectionId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;protections WHERE id = ?\&quot;);             statement.setInt(1, protectionId);              int affected = statement.executeUpdate();              if (affected &gt;= 1) {                 protectionCount -= affected;             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          // removeProtectionHistory(protectionId);     }      public void removeProtectionHistory(int protectionId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;history WHERE protectionId = ?\&quot;);             statement.setInt(1, protectionId);              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      public void removeHistory(int historyId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;history WHERE id = ?\&quot;);             statement.setInt(1, historyId);              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Remove **&lt;b&gt;ALL&lt;/b&gt;** all of the protections registered by LWC      */     public void removeAllProtections() {         try {             Connection connection = createConnection();             Statement statement = connection.createStatement();             statement.executeUpdate(\&quot;DELETE FROM \&quot; + prefix + \&quot;protections\&quot;);             protectionCount = 0;             statement.close();             connection.close();         } catch (SQLException e) {             printException(e);         }     }      /**      * Attempt to create an index on the table      *      * @param table      * @param indexName      * @param columns      */     private void createIndex(String table, String indexName, String columns) {         Connection connection = null;         Statement statement = null;          try {             connection = createConnection();             statement = connection.createStatement();             statement.executeUpdate(\&quot;CREATE INDEX\&quot; + (currentType == Type.SQLite ? \&quot; IF NOT EXISTS\&quot; : \&quot;\&quot;) + \&quot; \&quot; + indexName + \&quot; ON \&quot; + prefix + table + \&quot; (\&quot; + columns + \&quot;)\&quot;);         } catch (Exception e) {         } finally {             if (statement != null) {                 try {                     statement.close();                 } catch (SQLException e) {                 }             }             if (connection != null) {                 try {                     connection.close();                 } catch (SQLException e) {                 }             }         }     }      /**      * Attempt to create an index on the table      *      * @param indexName      */     private void dropIndex(String table, String indexName) {         Connection connection = null;         Statement statement = null;          try {             connection = createConnection();             statement = connection.createStatement();              if (currentType == Type.SQLite) {                 statement.executeUpdate(\&quot;DROP INDEX IF EXISTS \&quot; + indexName);             } else {                 statement.executeUpdate(\&quot;DROP INDEX \&quot; + indexName + \&quot; ON \&quot; + prefix + table);             }         } catch (Exception e) {         } finally {             if (statement != null) {                 try {                     statement.close();                 } catch (SQLException e) {                 }             }             if (connection != null) {                 try {                     connection.close();                 } catch (SQLException e) {                 }             }         }     }  } &quot;</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>&quot;/*  * Copyright 2011 Tyler Blair. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *    1. Redistributions of source code must retain the above copyright notice, this list of  *       conditions and the following disclaimer.  *  *    2. Redistributions in binary form must reproduce the above copyright notice, this list  *       of conditions and the following disclaimer in the documentation and/or other materials  *       provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are those of the  * authors and contributors and should not be interpreted as representing official policies,  * either expressed or implied, of anybody else.  */  package com.griefcraft.sql;  import com.griefcraft.cache.ProtectionCache; import com.griefcraft.lwc.LWC; import com.griefcraft.model.Flag; import com.griefcraft.model.History; import com.griefcraft.model.Permission; import com.griefcraft.model.Protection; import org.bukkit.entity.Player; import org.json.simple.JSONArray; import org.json.simple.JSONObject; import org.json.simple.parser.JSONParser;  import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.sql.Timestamp; import java.util.ArrayList; import java.util.Date; import java.util.List;  public class PhysDB extends Database {      /**      * The JSON Parser object      */     private final JSONParser jsonParser = new JSONParser();      /**      * The database version      */     private int databaseVersion = 0;      /**      * The number of protections that should exist      */     private int protectionCount = 0;      public PhysDB() {         super();     }      public PhysDB(Type currentType) {         super(currentType);     }      /**      * Decrement the known protection counter      */     public void decrementProtectionCount() {         protectionCount --;     }      /**      * Check if the protection cache has all of the known protections cached      *      * @return      */     public boolean hasAllProtectionsCached() {         ProtectionCache cache = LWC.getInstance().getProtectionCache();          return cache.size() &gt;= protectionCount;     }      /**      * Fetch an object from the sql database      *      * @param sql      * @param column      * @return      */     private Object fetch(String sql, String column, Object... toBind) {         PreparedStatement statement = null;         try {             int index = 1;             statement = prepare(sql);              for (Object bind : toBind) {                 statement.setObject(index, bind);                 index++;             }              ResultSet set = statement.executeQuery();              if (set.next()) {                 Object object = set.getObject(column);                 set.close();                 return object;             }              set.close();         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Get the total amount of protections      * @return the number of protections      */     public int getProtectionCount() {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections\&quot;, \&quot;count\&quot;).toString());     }      /**      * Get the amount of protections for the given protection type      * @param type      * @return the number of protected chests      */     public int getProtectionCount(Protection.Type type) {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections WHERE type = \&quot; + type.ordinal(), \&quot;count\&quot;).toString());     }      /**      * @return the number of history items stored      */     public int getHistoryCount() {         return Integer.decode(fetch(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;history\&quot;, \&quot;count\&quot;).toString());     }      /**      * Get the amount of protections a player has      *      * @param player      * @return the amount of protections they have      */     public int getProtectionCount(String player) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) as count FROM \&quot; + prefix + \&quot;protections WHERE owner = ?\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the amount of protections a player has      *      * @param player      * @return the amount of protections they have      */     public int getHistoryCount(String player) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?)\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the amount of chests a player has of a specific block id      *      * @param player      * @return the amount of protections they have of blockId      */     public int getProtectionCount(String player, int blockId) {         int count = 0;          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT COUNT(*) AS count FROM \&quot; + prefix + \&quot;protections WHERE owner = ? AND blockId = ?\&quot;);             statement.setString(1, player);             statement.setInt(2, blockId);              ResultSet set = statement.executeQuery();              if (set.next()) {                 count = set.getInt(\&quot;count\&quot;);             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return count;     }      /**      * Get the menu style for a player      *      * @param player      * @return      * @deprecated      */     public String getMenuStyle(String player) {         return \&quot;basic\&quot;;     }      /**      * Load the database and do any updating required or create the tables      */     @Override     public void load() {         if (loaded) {             return;         }          Column column;          Table protections = new Table(this, \&quot;protections\&quot;);         {             column = new Column(\&quot;id\&quot;);             column.setType(\&quot;INTEGER\&quot;);             column.setPrimary(true);             protections.add(column);              column = new Column(\&quot;owner\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;type\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;x\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;y\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;z\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;flags\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;data\&quot;);             column.setType(\&quot;TEXT\&quot;);             protections.add(column);              column = new Column(\&quot;blockId\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);              column = new Column(\&quot;world\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;password\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;date\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             protections.add(column);              column = new Column(\&quot;last_accessed\&quot;);             column.setType(\&quot;INTEGER\&quot;);             protections.add(column);         }          Table history = new Table(this, \&quot;history\&quot;);         {             column = new Column(\&quot;id\&quot;);             column.setType(\&quot;INTEGER\&quot;);             column.setPrimary(true);             history.add(column);              column = new Column(\&quot;protectionId\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;player\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             history.add(column);              column = new Column(\&quot;x\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;y\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;z\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;type\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;status\&quot;);             column.setType(\&quot;INTEGER\&quot;);             history.add(column);              column = new Column(\&quot;metadata\&quot;);             column.setType(\&quot;VARCHAR(255)\&quot;);             history.add(column);              column = new Column(\&quot;timestamp\&quot;);             column.setType(\&quot;long\&quot;);             history.add(column);         }          Table internal = new Table(this, \&quot;internal\&quot;);         {             column = new Column(\&quot;name\&quot;);             column.setType(\&quot;VARCHAR(40)\&quot;);             column.setPrimary(true);             column.setAutoIncrement(false);             internal.add(column);              column = new Column(\&quot;value\&quot;);             column.setType(\&quot;VARCHAR(40)\&quot;);             internal.add(column);         }          protections.execute();         history.execute();         internal.execute();          // Load the database version         loadDatabaseVersion();          // perform database upgrades         performDatabaseUpdates();          // get the amount of protections         protectionCount = getProtectionCount();          loaded = true;     }      /**      * Perform any database updates      */     public void performDatabaseUpdates() {          // Indexes         if (databaseVersion == 0) {             // Drop old, old indexes             log(\&quot;Dropping old indexes (One time, may take a while!)\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in1\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in6\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in7\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in8\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in9\&quot;);             dropIndex(\&quot;protections\&quot;, \&quot;in10\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in12\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in13\&quot;);             dropIndex(\&quot;history\&quot;, \&quot;in14\&quot;);              // Create our updated (good) indexes             log(\&quot;Creating new indexes (One time, may take a while!)\&quot;);             createIndex(\&quot;protections\&quot;, \&quot;protections_main\&quot;, \&quot;x, y, z, world\&quot;);             createIndex(\&quot;protections\&quot;, \&quot;protections_utility\&quot;, \&quot;owner\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_main\&quot;, \&quot;protectionId\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_utility\&quot;, \&quot;player\&quot;);             createIndex(\&quot;history\&quot;, \&quot;history_utility2\&quot;, \&quot;x, y, z\&quot;);              // increment the database version             incrementDatabaseVersion();         }          if (databaseVersion == 1) {             log(\&quot;Creating index on internal\&quot;);             createIndex(\&quot;internal\&quot;, \&quot;internal_main\&quot;, \&quot;name\&quot;);             incrementDatabaseVersion();         }          if (databaseVersion == 2) {             incrementDatabaseVersion();         }                  if (databaseVersion == 3) {             createIndex(\&quot;protections\&quot;, \&quot;protections_type\&quot;, \&quot;type\&quot;);             incrementDatabaseVersion();         }      }      /**      * Increment the database version      */     public void incrementDatabaseVersion() {         setDatabaseVersion(++databaseVersion);     }      /**      * Set the database version and sync it to the database      *       * @param databaseVersion      */     public void setDatabaseVersion(int databaseVersion) {         // set it locally         this.databaseVersion = databaseVersion;          // ship it to the database         PreparedStatement statement = null;         try {             statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;internal SET value = ? WHERE name = ?\&quot;);             statement.setInt(1, databaseVersion);             statement.setString(2, \&quot;version\&quot;);              // ok             statement.executeUpdate();         } catch (SQLException e) {          } finally {             safeClose(statement);         }     }      /**      * Get a value in the internal table      *      * @param key      * @return the value found, otherwise NULL if none exists      */     public String getInternal(String key) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT value FROM \&quot; + prefix + \&quot;internal WHERE name = ?\&quot;);             statement.setString(1, key);                          ResultSet set = statement.executeQuery();             if (set.next()) {                 String value = set.getString(\&quot;value\&quot;);                 set.close();                 return value;             }             set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Set a value in the internal table      *      * @param key      * @param value      */     public void setInternal(String key, String value) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;INSERT INTO \&quot; + prefix +\&quot;internal (name, value) VALUES (?, ?)\&quot;);             statement.setString(1, key);             statement.setString(2, value);              statement.executeUpdate();         } catch (SQLException e) {             safeClose(statement);             // Already exists             try {                 PreparedStatement statement2 = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;internal SET value = ? WHERE name = ?\&quot;);                 statement2.setString(1, value) ;                 statement2.setString(2, key);                  statement2.executeUpdate();             } catch (SQLException ex) {                 // Something bad went wrong                 printException(ex);             }         } finally {             safeClose(statement);         }     }      /**      * Load the database internal version      *      * @return      */     public int loadDatabaseVersion() {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT value FROM \&quot; + prefix + \&quot;internal WHERE name = ?\&quot;);             statement.setString(1, \&quot;version\&quot;);              // Execute it             ResultSet set = statement.executeQuery();              // load the version             if (set.next()) {                 databaseVersion = Integer.parseInt(set.getString(\&quot;value\&quot;));             } else {                 throw new IllegalStateException(\&quot;Internal is empty\&quot;);             }              // close everything             set.close();         } catch (Exception e) {             safeClose(statement);             // Doesn't exist, create it             try {                 PreparedStatement statement2 = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;internal (name, value) VALUES(?, ?)\&quot;);                 statement2.setString(1, \&quot;version\&quot;);                 statement2.setInt(2, databaseVersion);                  // ok                 statement2.executeUpdate();                 statement2.close();             } catch (SQLException ex) { }         } finally {             safeClose(statement);         }          return databaseVersion;     }      /**      * Load a protection with the given id      *      * @param id      * @return the Chest object      */     public Protection loadProtection(int id) {         // the protection cache         ProtectionCache cache = LWC.getInstance().getProtectionCache();          // check if the protection is already cached         Protection cached = cache.getProtectionById(id);         if (cached != null) {             return cached;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE id = ?\&quot;);             statement.setInt(1, id);              Protection protection = resolveProtection(statement);              if (protection != null) {                 cache.add(protection);                 return protection;             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load protections using a specific type      *      * @param type      * @return the Protection object      */     public List&lt;Protection&gt; loadProtectionsUsingType(Protection.Type type) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE type = ?\&quot;);             statement.setInt(1, type.ordinal());              return resolveProtections(statement);         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Resolve one protection from a ResultSet. The ResultSet is not closed.      *      * @param set      * @return      */     public Protection resolveProtection(ResultSet set) {         try {             Protection protection = new Protection();              int protectionId = set.getInt(\&quot;id\&quot;);             int x = set.getInt(\&quot;x\&quot;);             int y = set.getInt(\&quot;y\&quot;);             int z = set.getInt(\&quot;z\&quot;);             int blockId = set.getInt(\&quot;blockId\&quot;);             int type = set.getInt(\&quot;type\&quot;);             String world = set.getString(\&quot;world\&quot;);             String owner = set.getString(\&quot;owner\&quot;);             String password = set.getString(\&quot;password\&quot;);             String date = set.getString(\&quot;date\&quot;);             long lastAccessed = set.getLong(\&quot;last_accessed\&quot;);              protection.setId(protectionId);             protection.setX(x);             protection.setY(y);             protection.setZ(z);             protection.setBlockId(blockId);             protection.setType(Protection.Type.values()[type]);             protection.setWorld(world);             protection.setOwner(owner);             protection.setPassword(password);             protection.setCreation(date);             protection.setLastAccessed(lastAccessed);              // check for oh so beautiful data!             String data = set.getString(\&quot;data\&quot;);              if (data == null || data.trim().isEmpty()) {                 return protection;             }              // rev up them JSON parsers!             Object object = null;              try {                 object = jsonParser.parse(data);             } catch (Exception e) {                 return protection;             } catch (Error e) {                 return protection;             }              if (!(object instanceof JSONObject)) {                 return protection;             }              // obtain the root             JSONObject root = (JSONObject) object;             protection.getData().putAll(root);              // Attempt to parse rights             Object rights = root.get(\&quot;rights\&quot;);              if (rights != null &amp;&amp; (rights instanceof JSONArray)) {                 JSONArray array = (JSONArray) rights;                  for (Object node : array) {                     // we only want to use the maps                     if (!(node instanceof JSONObject)) {                         continue;                     }                      JSONObject map = (JSONObject) node;                      // decode the map                     Permission permission = Permission.decodeJSON(map);                      // bingo!                     if (permission != null) {                         protection.addPermission(permission);                     }                 }             }              // Attempt to parse flags             Object flags = root.get(\&quot;flags\&quot;);             if (flags != null &amp;&amp; (rights instanceof JSONArray)) {                 JSONArray array = (JSONArray) flags;                  for (Object node : array) {                     if (!(node instanceof JSONObject)) {                         continue;                     }                      JSONObject map = (JSONObject) node;                      Flag flag = Flag.decodeJSON(map);                      if (flag != null) {                         protection.addFlag(flag);                     }                 }             }              return protection;         } catch (SQLException e) {             printException(e);             return null;         }     }      /**      * Resolve every protection from a result set      *      * @param set      * @return      */     private List&lt;Protection&gt; resolveProtections(ResultSet set) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          try {             while (set.next()) {                 Protection protection = resolveProtection(set);                  if (protection != null) {                     protections.add(protection);                 }             }         } catch (SQLException e) {             printException(e);         }          return protections;     }      /**      * Resolve a list of protections from a statement      *      * @param statement      * @return      */     private List&lt;Protection&gt; resolveProtections(PreparedStatement statement) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();         ResultSet set = null;          try {             set = statement.executeQuery();             protections = resolveProtections(set);         } catch (SQLException e) {             printException(e);         } finally {             if (set != null) {                 try {                     set.close();                 } catch (SQLException e) {                 }             }         }          return protections;     }      /**      * Resolve the first protection from a statement      *      * @param statement      * @return      */     private Protection resolveProtection(PreparedStatement statement) {         List&lt;Protection&gt; protections = resolveProtections(statement);          if (protections.size() == 0) {             return null;         }          return protections.get(0);     }      /**      * Fill the protection cache as much as possible with protections      * Caches the most recent protections      */     public void precache() {         LWC lwc = LWC.getInstance();         ProtectionCache cache = lwc.getProtectionCache();          // clear the cache incase we're working on a dirty cache         cache.clear();          int precacheSize = lwc.getConfiguration().getInt(\&quot;core.precache\&quot;, -1);          if (precacheSize == -1) {             precacheSize = lwc.getConfiguration().getInt(\&quot;core.cacheSize\&quot;, 10000);         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections ORDER BY id DESC LIMIT ?\&quot;);             statement.setInt(1, precacheSize);             statement.setFetchSize(10);              // scrape the protections from the result set now             List&lt;Protection&gt; protections = resolveProtections(statement);              // throw all of the protections in             for (Protection protection : protections) {                 cache.add(protection);             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          // Cache them all     }      /**      * Load a protection at the given coordinates      *      * @param x      * @param y      * @param z      * @return the Protection object      */     public Protection loadProtection(String worldName, int x, int y, int z) {         return loadProtection(worldName, x, y, z, false);     }      /**      * Load a protection at the given coordinates      *      * @param x      * @param y      * @param z      * @param ignoreProtectionCount      * @return the Protection object      */     private Protection loadProtection(String worldName, int x, int y, int z, boolean ignoreProtectionCount) {         // the unique key to use in the cache         String cacheKey = worldName + \&quot;:\&quot; + x + \&quot;:\&quot; + y + \&quot;:\&quot; + z;          // the protection cache         ProtectionCache cache = LWC.getInstance().getProtectionCache();          // check if the protection is already cached         Protection cached = cache.getProtection(cacheKey);         if (cached != null) {             // System.out.println(\&quot;loadProtection() =&gt; CACHE HIT\&quot;);             return cached;         }          // Is it possible that there are protections in the cache?         if (!ignoreProtectionCount &amp;&amp; hasAllProtectionsCached()) {             // System.out.println(\&quot;loadProtection() =&gt; HAS_ALL_PROTECTIONS_CACHED\&quot;);             return null; // nothing was in the cache, nothing assumed to be in the database         }         // System.out.println(\&quot;loadProtection() =&gt; QUERYING\&quot;);          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE x = ? AND y = ? AND z = ? AND world = ?\&quot;);             statement.setInt(1, x);             statement.setInt(2, y);             statement.setInt(3, z);             statement.setString(4, worldName);              Protection protection = resolveProtection(statement);              if (protection != null) {                 // cache the protection                 cache.add(protection);             }              return protection;         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load all protections (use sparingly !!)      *      * @return      */     public List&lt;Protection&gt; loadProtections() {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections\&quot;);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Load the first protection within a block's radius      *      * @param world      * @param x      * @param y      * @param z      * @param radius      * @return list of Protection objects found      */     public List&lt;Protection&gt; loadProtections(String world, int x, int y, int z, int radius) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE world = ? AND x &gt;= ? AND x &lt;= ? AND y &gt;= ? AND y &lt;= ? AND z &gt;= ? AND z &lt;= ?\&quot;);              statement.setString(1, world);             statement.setInt(2, x - radius);             statement.setInt(3, x + radius);             statement.setInt(4, y - radius);             statement.setInt(5, y + radius);             statement.setInt(6, z - radius);             statement.setInt(7, z + radius);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Remove all protections for a given player      *      * @param player      * @return the amount of protections removed      */     public int removeProtectionsByPlayer(String player) {         int removed = 0;          for (Protection protection : loadProtectionsByPlayer(player)) {             protection.remove();             removed ++;         }          return removed;     }      /**      * Load all protections in the coordinate ranges      *      * @param world      * @param x1      * @param x2      * @param y1      * @param y2      * @param z1      * @param z2      * @return list of Protection objects found      */     public List&lt;Protection&gt; loadProtections(String world, int x1, int x2, int y1, int y2, int z1, int z2) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE world = ? AND x &gt;= ? AND x &lt;= ? AND y &gt;= ? AND y &lt;= ? AND z &gt;= ? AND z &lt;= ?\&quot;);              statement.setString(1, world);             statement.setInt(2, x1);             statement.setInt(3, x2);             statement.setInt(4, y1);             statement.setInt(5, y2);             statement.setInt(6, z1);             statement.setInt(7, z2);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return new ArrayList&lt;Protection&gt;();     }      /**      * Load protections by a player      *      * @param player      * @return      */     public List&lt;Protection&gt; loadProtectionsByPlayer(String player) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE owner = ?\&quot;);             statement.setString(1, player);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return protections;     }      /**      * Load protections by a player      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;Protection&gt; loadProtectionsByPlayer(String player, int start, int count) {         List&lt;Protection&gt; protections = new ArrayList&lt;Protection&gt;();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT id, owner, type, x, y, z, data, blockId, world, password, date, last_accessed FROM \&quot; + prefix + \&quot;protections WHERE owner = ? ORDER BY id DESC limit ?,?\&quot;);             statement.setString(1, player);             statement.setInt(2, start);             statement.setInt(3, count);              return resolveProtections(statement);         } catch (Exception e) {             printException(e);         } finally {             safeClose(statement);         }          return protections;     }      /**      * Register a protection      *      * @param blockId      * @param type      * @param world      * @param player      * @param data      * @param x      * @param y      * @param z      * @return      */     @Deprecated     public Protection registerProtection(int blockId, int type, String world, String player, String data, int x, int y, int z) {         return registerProtection(blockId, Protection.Type.values()[type], world, player, data, x, y, z);     }      /**      * Register a protection      *      * @param blockId      * @param type      * @param world      * @param player      * @param data      * @param x      * @param y      * @param z      * @return      */     public Protection registerProtection(int blockId, Protection.Type type, String world, String player, String data, int x, int y, int z) {         ProtectionCache cache = LWC.getInstance().getProtectionCache();          PreparedStatement statement = null;         try {             statement = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;protections (blockId, type, world, owner, password, x, y, z, date, last_accessed) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;);              statement.setInt(1, blockId);             statement.setInt(2, type.ordinal());             statement.setString(3, world);             statement.setString(4, player);             statement.setString(5, data);             statement.setInt(6, x);             statement.setInt(7, y);             statement.setInt(8, z);             statement.setString(9, new Timestamp(new Date().getTime()).toString());             statement.setLong(10, System.currentTimeMillis() / 1000L);              statement.executeUpdate();              // We need to create the initial transaction for this protection             // this transaction is viewable and modifiable during POST_REGISTRATION             Protection protection = loadProtection(world, x, y, z, true);              // if history logging is enabled, create it             if (LWC.getInstance().isHistoryEnabled() &amp;&amp; protection != null) {                 History transaction = protection.createHistoryObject();                  transaction.setPlayer(player);                 transaction.setType(History.Type.TRANSACTION);                 transaction.setStatus(History.Status.ACTIVE);                  // store the player that created the protection                 transaction.addMetaData(\&quot;creator=\&quot; + player);                  // now sync the history object to the database                 transaction.saveNow();             }                          // Cache it             if (protection != null) {                 cache.add(protection);                 protectionCount ++;             }              // return the newly created protection             return protection;         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Sync a History object to the database or save a newly created one      *      * @param history      */     public void saveHistory(History history) {         PreparedStatement statement = null;         try {             if (history.doesExist()) {                 statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;history SET protectionId = ?, player = ?, x = ?, y = ?, z = ?, type = ?, status = ?, metadata = ?, timestamp = ? WHERE id = ?\&quot;);             } else {                 statement = prepare(\&quot;INSERT INTO \&quot; + prefix + \&quot;history (protectionId, player, x, y, z, type, status, metadata, timestamp) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;, true);                 history.setTimestamp(System.currentTimeMillis() / 1000L);             }              statement.setInt(1, history.getProtectionId());             statement.setString(2, history.getPlayer());             statement.setInt(3, history.getX());             statement.setInt(4, history.getY());             statement.setInt(5, history.getZ());             statement.setInt(6, history.getType().ordinal());             statement.setInt(7, history.getStatus().ordinal());             statement.setString(8, history.getSafeMetaData());             statement.setLong(9, history.getTimestamp());              if (history.doesExist()) {                 statement.setInt(10, history.getId());             }              int affectedRows;              if (statement instanceof AutoClosingPreparedStatement) {                 affectedRows = ((AutoClosingPreparedStatement) statement).executeUpdate(false);             } else {                 affectedRows = statement.executeUpdate();             }              // set the history id if inserting             if (!history.doesExist()) {                 if (affectedRows &gt; 0) {                     ResultSet generatedKeys = statement.getGeneratedKeys();                      // get the key inserted                     if (generatedKeys.next()) {                         history.setId(generatedKeys.getInt(1));                     }                      generatedKeys.close();                 }             }              statement.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Invalid all history objects for a player      *       * @param player      */     public void invalidateHistory(String player) {        try {            PreparedStatement statement = prepare(\&quot;UPDATE \&quot; + prefix + \&quot;history SET status = ? WHERE Lower(player) = Lower(?)\&quot;);            statement.setInt(1, History.Status.INACTIVE.ordinal());            statement.setString(2, player);             statement.executeUpdate();        } catch (SQLException e) {            printException(e);        }     }      /**      * Resolve 1 history object from the result set but do not close it      *      * @return      */     private History resolveHistory(History history, ResultSet set) throws SQLException {         if (history == null) {             return null;         }          int historyId = set.getInt(\&quot;id\&quot;);         int protectionId = set.getInt(\&quot;protectionId\&quot;);         int x = set.getInt(\&quot;x\&quot;);         int y = set.getInt(\&quot;y\&quot;);         int z = set.getInt(\&quot;z\&quot;);         String player = set.getString(\&quot;player\&quot;);         int type_ord = set.getInt(\&quot;type\&quot;);         int status_ord = set.getInt(\&quot;status\&quot;);         String[] metadata = set.getString(\&quot;metadata\&quot;).split(\&quot;,\&quot;);         long timestamp = set.getLong(\&quot;timestamp\&quot;);          History.Type type = History.Type.values()[type_ord];         History.Status status = History.Status.values()[status_ord];          history.setId(historyId);         history.setProtectionId(protectionId);         history.setType(type);         history.setPlayer(player);         history.setX(x);         history.setY(y);         history.setZ(z);         history.setStatus(status);         history.setMetaData(metadata);         history.setTimestamp(timestamp);          return history;     }      /**      * Load all of the History objects for a given protection      *      * @param protection      * @return      */     public List&lt;History&gt; loadHistory(Protection protection) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE protectionId = ? ORDER BY id DESC\&quot;);             statement.setInt(1, protection.getId());              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(protection.createHistoryObject(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history that the given player created      *      * @param player      * @return      */     public List&lt;History&gt; loadHistory(Player player) {         return loadHistory(player.getName());     }      /**      * Load all protection history that the given player created      *      * @param player      * @return      */     public List&lt;History&gt; loadHistory(String player) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) ORDER BY id DESC\&quot;);             statement.setString(1, player);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history that has the given history id      *      * @param historyId      * @return      */     public History loadHistory(int historyId) {         if (!LWC.getInstance().isHistoryEnabled()) {             return null;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE id = ?\&quot;);             statement.setInt(1, historyId);              ResultSet set = statement.executeQuery();              if (set.next()) {                 History history = resolveHistory(new History(), set);                  set.close();                 return history;             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return null;     }      /**      * Load all protection history that the given player created for a given page, getting count history items.      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;History&gt; loadHistory(Player player, int start, int count) {         return loadHistory(player.getName(), start, count);     }      /**      * Load all protection history that the given player created for a given page, getting count history items.      *      * @param player      * @param start      * @param count      * @return      */     public List&lt;History&gt; loadHistory(String player, int start, int count) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) ORDER BY id DESC LIMIT ?,?\&quot;);             statement.setString(1, player);             statement.setInt(2, start);             statement.setInt(3, count);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history      *      * @return      */     public List&lt;History&gt; loadHistory() {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history ORDER BY\&quot; + id + \&quot;DESC\&quot;);             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history ORDER BY   \&quot;              \t+ id + \&quot;DESC\&quot;);             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history order BY             \t\&quot; + id + \&quot;DESC\&quot;);             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history order By\&quot; + id + \&quot;DESC\&quot;);             ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history for the given status      *      * @return      */     public List&lt;History&gt; loadHistory(History.Status status) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE status = ? ORDER BY id DESC\&quot;);             statement.setInt(1, status.ordinal());             ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all of the history at the given location      *      * @param x      * @param y      * @param z      * @return      */     public List&lt;History&gt; loadHistory(int x, int y, int z) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE x = ? AND y = ? AND z = ?\&quot;);             statement.setInt(1, x);             statement.setInt(2, y);             statement.setInt(3, z);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all of the history at the given location      *      * @param player      * @param x      * @param y      * @param z      * @return      */     public List&lt;History&gt; loadHistory(String player, int x, int y, int z) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history WHERE LOWER(player) = LOWER(?) AND x = ? AND y = ? AND z = ?\&quot;);             statement.setString(1, player);             statement.setInt(2, x);             statement.setInt(3, y);             statement.setInt(4, z);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Load all protection history      *      * @return      */     public List&lt;History&gt; loadHistory(int start, int count) {         List&lt;History&gt; temp = new ArrayList&lt;History&gt;();          if (!LWC.getInstance().isHistoryEnabled()) {             return temp;         }          PreparedStatement statement = null;         try {             statement = prepare(\&quot;SELECT * FROM \&quot; + prefix + \&quot;history ORDER BY id DESC LIMIT ?,?\&quot;);             statement.setInt(1, start);             statement.setInt(2, count);              ResultSet set = statement.executeQuery();              while (set.next()) {                 History history = resolveHistory(new History(), set);                  if (history != null) {                     // seems ok                     temp.add(history);                 }             }              set.close();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          return temp;     }      /**      * Save a protection to the database      *      * @param protection      */     public void saveProtection(Protection protection) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;REPLACE INTO \&quot;              \t+ prefix + \&quot;protections (id, type, blockId, world, data, owner, password, x, y, z, date, last_accessed) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\&quot;);              statement.setInt(1, protection.getId());             statement.setInt(2, protection.getType().ordinal());             statement.setInt(3, protection.getBlockId());             statement.setString(4, protection.getWorld());             statement.setString(5, protection.getData().toJSONString());             statement.setString(6, protection.getOwner());             statement.setString(7, protection.getPassword());             statement.setInt(8, protection.getX());             statement.setInt(9, protection.getY());             statement.setInt(10, protection.getZ());             statement.setString(11, protection.getCreation());             statement.setLong(12, protection.getLastAccessed());              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Free a chest from protection      *      * @param protectionId the protection Id      */     public void removeProtection(int protectionId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;protections WHERE id = ?\&quot;);             statement.setInt(1, protectionId);              int affected = statement.executeUpdate();              if (affected &gt;= 1) {                 protectionCount -= affected;             }         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }          // removeProtectionHistory(protectionId);     }      public void removeProtectionHistory(int protectionId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;history WHERE protectionId = ?\&quot;);             statement.setInt(1, protectionId);              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      public void removeHistory(int historyId) {         PreparedStatement statement = null;         try {             statement = prepare(\&quot;DELETE FROM \&quot; + prefix + \&quot;history WHERE id = ?\&quot;);             statement.setInt(1, historyId);              statement.executeUpdate();         } catch (SQLException e) {             printException(e);         } finally {             safeClose(statement);         }     }      /**      * Remove **&lt;b&gt;ALL&lt;/b&gt;** all of the protections registered by LWC      */     public void removeAllProtections() {         try {             Connection connection = createConnection();             Statement statement = connection.createStatement();             statement.executeUpdate(\&quot;DELETE FROM \&quot; + prefix + \&quot;protections\&quot;);             protectionCount = 0;             statement.close();             connection.close();         } catch (SQLException e) {             printException(e);         }     }      /**      * Attempt to create an index on the table      *      * @param table      * @param indexName      * @param columns      */     private void createIndex(String table, String indexName, String columns) {         Connection connection = null;         Statement statement = null;          try {             connection = createConnection();             statement = connection.createStatement();             statement.executeUpdate(\&quot;CREATE INDEX\&quot; + (currentType == Type.SQLite ? \&quot; IF NOT EXISTS\&quot; : \&quot;\&quot;) + \&quot; \&quot; + indexName + \&quot; ON \&quot; + prefix + table + \&quot; (\&quot; + columns + \&quot;)\&quot;);         } catch (Exception e) {         } finally {             if (statement != null) {                 try {                     statement.close();                 } catch (SQLException e) {                 }             }             if (connection != null) {                 try {                     connection.close();                 } catch (SQLException e) {                 }             }         }     }      /**      * Attempt to create an index on the table      *      * @param indexName      */     private void dropIndex(String table, String indexName) {         Connection connection = null;         Statement statement = null;          try {             connection = createConnection();             statement = connection.createStatement();              if (currentType == Type.SQLite) {                 statement.executeUpdate(\&quot;DROP INDEX IF EXISTS \&quot; + indexName);             } else {                 statement.executeUpdate(\&quot;DROP INDEX \&quot; + indexName + \&quot; ON \&quot; + prefix + table);             }         } catch (Exception e) {         } finally {             if (statement != null) {                 try {                     statement.close();                 } catch (SQLException e) {                 }             }             if (connection != null) {                 try {                     connection.close();                 } catch (SQLException e) {                 }             }         }     }  } &quot;</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>&quot;https://searchcode.com/codesearch/raw/40482803/&quot;</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>https://searchcode.com/codesearch/raw/40482803/</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
    </expressions>
    <expressions id="evaluateExpression">
      <expression>
        <expression-string>code</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>searchData.getCode()</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>matcher.find()</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>scp</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>stringLitWithVarMatcher.group()</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>stringLitWithVarMatcher.find()</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>stringLitWithVarMatcher.</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>stringLitWithVarMatcher.lookingAt()</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
      <expression>
        <expression-string>stringLitWithVarMatcher.matches()</expression-string>
        <language-id>JAVA</language-id>
        <evaluation-mode>EXPRESSION</evaluation-mode>
      </expression>
    </expressions>
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="312">
          <caret line="27" column="17" selection-start-line="27" selection-start-column="17" selection-end-line="27" selection-end-column="17" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeAnalyzer.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="295">
          <caret line="76" column="24" lean-forward="true" selection-start-line="76" selection-start-column="24" selection-end-line="76" selection-end-column="24" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="360">
          <caret line="29" column="27" selection-start-line="29" selection-start-column="27" selection-end-line="29" selection-end-column="27" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/UrlConstants.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="60">
          <caret line="4" column="49" lean-forward="true" selection-start-line="4" selection-start-column="49" selection-end-line="4" selection-end-column="136" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeStatistics.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="675">
          <caret line="48" column="5" lean-forward="true" selection-start-line="48" selection-start-column="5" selection-end-line="48" selection-end-column="5" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/RegexConstants.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="225">
          <caret line="15" column="1" lean-forward="true" selection-start-line="15" selection-start-column="1" selection-end-line="15" selection-end-column="1" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeAnalyzer.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="195">
          <caret line="18" column="12" selection-start-line="18" selection-end-line="19" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="360">
          <caret line="29" column="27" selection-start-line="29" selection-start-column="27" selection-end-line="29" selection-end-column="27" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeStatistics.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="600">
          <caret line="43" column="61" selection-start-line="43" selection-start-column="61" selection-end-line="43" selection-end-column="61" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/UrlConstants.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="60">
          <caret line="4" column="113" selection-start-line="4" selection-start-column="113" selection-end-line="4" selection-end-column="113" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="195">
          <caret line="18" column="58" selection-start-line="18" selection-start-column="58" selection-end-line="18" selection-end-column="58" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SearchData.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="390">
          <caret line="36" selection-start-line="36" selection-end-line="36" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeStatistics.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="570">
          <caret line="41" column="49" selection-start-line="41" selection-start-column="49" selection-end-line="41" selection-end-column="49" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/provider/SearchCodeProvider.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="255">
          <caret line="31" selection-start-line="31" selection-end-line="31" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/Results.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="30">
          <caret line="2" column="13" selection-start-line="2" selection-start-column="13" selection-end-line="2" selection-end-column="13" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeAnalyzer.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="660">
          <caret line="49" selection-start-line="49" selection-end-line="49" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/RegexConstants.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="90">
          <caret line="6" column="1" selection-start-line="6" selection-start-column="1" selection-end-line="6" selection-end-column="1" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="195">
          <caret line="17" column="50" selection-start-line="17" selection-start-column="50" selection-end-line="17" selection-end-column="50" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/UrlConstants.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="90">
          <caret line="6" lean-forward="true" selection-start-line="6" selection-end-line="6" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/RegexConstants.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="90">
          <caret line="6" column="60" selection-start-line="6" selection-start-column="60" selection-end-line="6" selection-end-column="60" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeAnalyzer.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="660">
          <caret line="48" column="27" selection-start-line="48" selection-start-column="27" selection-end-line="48" selection-end-column="27" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="315">
          <caret line="21" column="38" lean-forward="true" selection-start-line="21" selection-start-column="38" selection-end-line="21" selection-end-column="38" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SQLType.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="75">
          <caret line="5" lean-forward="true" selection-start-line="5" selection-end-line="5" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/UrlConstants.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="90">
          <caret line="6" lean-forward="true" selection-start-line="6" selection-end-line="6" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/pom.xml">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="435">
          <caret line="29" column="21" selection-start-line="29" selection-start-column="21" selection-end-line="29" selection-end-column="21" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/JavaCodeParser.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="90">
          <caret line="8" column="38" selection-start-line="8" selection-start-column="38" selection-end-line="8" selection-end-column="38" />
          <folding>
            <element signature="imports" expanded="true" />
            <element signature="e#227#228#0" expanded="true" />
            <element signature="e#272#273#0" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="165">
          <caret line="12" lean-forward="true" selection-start-line="12" selection-end-line="12" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/CredentialConstants.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="90">
          <caret line="6" column="88" selection-start-line="6" selection-start-column="48" selection-end-line="6" selection-end-column="88" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/JavaCodeParser.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="165">
          <caret line="11" lean-forward="true" selection-start-line="11" selection-end-line="11" />
          <folding>
            <element signature="imports" expanded="true" />
            <element signature="e#227#228#0" expanded="true" />
            <element signature="e#272#273#0" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/Lines.java" />
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/LanguageFilters.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="195">
          <caret line="13" column="23" selection-start-line="13" selection-start-column="23" selection-end-line="13" selection-end-column="23" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SearchCodeResult.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="278">
          <caret line="56" lean-forward="true" selection-start-line="56" selection-end-line="56" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/utils/UrlUtils.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="75">
          <caret line="5" selection-start-line="5" selection-end-line="5" />
        </state>
      </provider>
    </entry>
    <entry file="jar:///Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/src.zip!/java/util/Queue.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="250">
          <caret line="209" lean-forward="true" selection-start-line="209" selection-end-line="209" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/CredentialConstants.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="90">
          <caret line="6" column="88" selection-start-line="6" selection-start-column="48" selection-end-line="6" selection-end-column="88" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/pom.xml">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="392">
          <caret line="39" column="21" selection-start-line="39" selection-start-column="21" selection-end-line="39" selection-end-column="21" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/Results.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="15">
          <caret line="2" column="13" selection-start-line="2" selection-start-column="13" selection-end-line="2" selection-end-column="13" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/provider/SourceCodeProvider.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="180">
          <caret line="12" lean-forward="true" selection-start-line="12" selection-end-line="12" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/io/HttpConnection.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="180">
          <caret line="12" column="44" selection-start-line="12" selection-start-column="41" selection-end-line="12" selection-end-column="44" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/provider/SearchCodeProvider.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="264">
          <caret line="31" column="60" selection-start-line="31" selection-start-column="60" selection-end-line="31" selection-end-column="60" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeStatDTO.java" />
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/CodeStatData.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="147">
          <caret line="29" column="33" selection-start-line="29" selection-start-column="33" selection-end-line="29" selection-end-column="33" />
        </state>
      </provider>
    </entry>
    <entry file="jar:///Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/src.zip!/java/sql/Ref.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="166">
          <caret line="53" column="17" selection-start-line="53" selection-start-column="17" selection-end-line="53" selection-end-column="17" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SQLType.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="75">
          <caret line="5" lean-forward="true" selection-start-line="5" selection-end-line="5" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SQLTypeDTO.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="300">
          <caret line="20" column="34" selection-start-line="20" selection-start-column="19" selection-end-line="20" selection-end-column="34" />
          <folding>
            <element signature="e#316#317#0" expanded="true" />
            <element signature="e#347#348#0" expanded="true" />
            <element signature="e#553#554#0" expanded="true" />
            <element signature="e#587#588#0" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeStatistics.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="1530">
          <caret line="102" column="54" selection-start-line="102" selection-start-column="54" selection-end-line="102" selection-end-column="54" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/model/SearchData.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="309">
          <caret line="36" selection-start-line="36" selection-end-line="36" />
          <folding>
            <element signature="e#733#734#0" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/UrlConstants.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="90">
          <caret line="6" column="52" selection-start-line="6" selection-start-column="52" selection-end-line="6" selection-end-column="52" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/CrawlerMain.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="248">
          <caret line="24" selection-start-line="24" selection-end-line="24" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/analyze/CodeAnalyzer.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="151">
          <caret line="63" column="57" selection-start-line="63" selection-start-column="53" selection-end-line="63" selection-end-column="57" />
          <folding>
            <element signature="imports" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/main/java/usf/edu/bronie/sqlcrawler/constants/RegexConstants.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="60">
          <caret line="4" column="112" selection-start-line="4" selection-start-column="67" selection-end-line="4" selection-end-column="112" />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>